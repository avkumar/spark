<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spark • Quantum Image Gallery</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      width: 100%;
      background: radial-gradient(ellipse at center, #0a0a0a 0%, #1a1a2e 30%, #16213e 70%, #0f3460 100%);
      font-family: 'Inter', 'Arial', sans-serif;
      overflow: hidden;
      color: white;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      outline: none;
      touch-action: none;
    }
    
    /* Quantum UI Design */
    #quantum-interface {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.9);
      padding: 25px;
      border-radius: 20px;
      color: white;
      backdrop-filter: blur(20px);
      border: 2px solid rgba(0, 255, 255, 0.3);
      min-width: 350px;
      box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
      transition: all 0.3s ease;
    }
    
    #quantum-interface:hover {
      border-color: rgba(0, 255, 255, 0.6);
      box-shadow: 0 12px 40px rgba(0, 255, 255, 0.3);
    }
    
    #quantum-interface h3 {
      margin: 0 0 20px 0;
      color: #00ffff;
      text-align: center;
      font-size: 22px;
      font-weight: 600;
      text-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
    }
    
    .quantum-control {
      margin-bottom: 20px;
    }
    
    .quantum-control label {
      display: block;
      margin-bottom: 8px;
      color: #00ffff;
      font-size: 14px;
      font-weight: 500;
    }
    
    .quantum-control input[type="range"] {
      width: 100%;
      margin-bottom: 5px;
      -webkit-appearance: none;
      appearance: none;
      height: 8px;
      border-radius: 4px;
      background: rgba(0, 255, 255, 0.2);
      outline: none;
      transition: all 0.3s;
    }
    
    .quantum-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: linear-gradient(135deg, #00ffff, #0080ff);
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
    }
    
    .quantum-control input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.3);
      box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
    }
    
    .quantum-control select {
      width: 100%;
      padding: 12px;
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 8px;
      color: white;
      font-size: 14px;
      transition: all 0.3s;
    }
    
    .quantum-control select:focus {
      outline: none;
      border-color: #00ffff;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
    }
    
    .quantum-control select option {
      background: #1a1a2e;
      color: white;
    }
    
    .quantum-button {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, #00ffff, #0080ff);
      border: none;
      color: #000;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      font-size: 14px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
      margin-bottom: 10px;
    }
    
    .quantum-button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0, 255, 255, 0.5);
    }
    
    .quantum-button.secondary {
      background: linear-gradient(135deg, #ff6b9d, #ff8ab3);
      box-shadow: 0 4px 15px rgba(255, 107, 157, 0.3);
    }
    
    .quantum-button.secondary:hover {
      box-shadow: 0 8px 25px rgba(255, 107, 157, 0.5);
    }
    
    .quantum-button.danger {
      background: linear-gradient(135deg, #ff5722, #f44336);
      box-shadow: 0 4px 15px rgba(255, 87, 34, 0.3);
    }
    
    .quantum-button.danger:hover {
      box-shadow: 0 8px 25px rgba(255, 87, 34, 0.5);
    }
    
    /* Quantum Stats */
    #quantum-stats {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 15px;
      color: white;
      backdrop-filter: blur(20px);
      border: 2px solid rgba(0, 255, 255, 0.3);
      font-family: 'Courier New', monospace;
      font-size: 12px;
      min-width: 250px;
    }
    
    #quantum-stats h4 {
      margin: 0 0 15px 0;
      color: #00ffff;
      font-size: 16px;
      text-align: center;
    }
    
    /* Quantum Portal */
    #quantum-portal {
      position: absolute;
      bottom: 20px;
      left: 20px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px;
      border-radius: 15px;
      color: white;
      backdrop-filter: blur(20px);
      border: 2px solid rgba(255, 107, 157, 0.3);
      font-size: 12px;
      line-height: 1.5;
      max-width: 350px;
    }
    
    #quantum-portal h4 {
      margin: 0 0 12px 0;
      color: #ff6b9d;
      font-size: 16px;
    }
    
    /* Quantum Counter */
    #quantum-counter {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 50;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px 30px;
      border-radius: 30px;
      color: white;
      backdrop-filter: blur(20px);
      font-size: 20px;
      font-weight: 700;
      opacity: 0;
      transition: opacity 0.5s;
      pointer-events: none;
      border: 2px solid rgba(0, 255, 255, 0.5);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
    }
    
    #quantum-counter.show {
      opacity: 1;
    }
    
    /* Quantum Loading */
    #quantum-loading {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at center, #0a0a0a 0%, #1a1a2e 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity 0.5s;
    }
    
    #quantum-loading.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .quantum-spinner {
      width: 80px;
      height: 80px;
      border: 4px solid rgba(0, 255, 255, 0.3);
      border-top: 4px solid #00ffff;
      border-radius: 50%;
      animation: quantum-spin 1.5s linear infinite;
      margin-bottom: 25px;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
    }
    
    @keyframes quantum-spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .quantum-text {
      color: #00ffff;
      font-size: 20px;
      font-weight: 600;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }
    
    /* Quantum Effects */
    .quantum-glow {
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
    }
    
    .quantum-pulse {
      animation: quantum-pulse 2s ease-in-out infinite;
    }
    
    @keyframes quantum-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      #quantum-interface {
        min-width: 300px;
        padding: 20px;
      }
      
      #quantum-portal, #quantum-stats {
        max-width: 280px;
        padding: 15px;
      }
    }
  </style>
</head>
<body>
  <!-- Quantum Loading Screen -->
  <div id="quantum-loading">
    <div class="quantum-spinner"></div>
    <div class="quantum-text">Initializing Quantum Gallery...</div>
  </div>

  <!-- Main Canvas -->
  <canvas id="canvas" tabindex="0"></canvas>
  
  <!-- Simple Quantum Interface -->
  <div id="quantum-interface">
    <h3>🌌 Quantum Gallery</h3>
    
    <div class="quantum-control">
      <label>Layout:</label>
      <select id="layoutMode">
        <option value="carousel">Carousel</option>
        <option value="grid">Grid</option>
        <option value="spiral">Spiral</option>
        <option value="galaxy">Galaxy</option>
      </select>
    </div>
    
    <div class="quantum-control">
      <label>Speed: <span id="speedValue">1.0</span></label>
      <input type="range" id="speed" min="0.1" max="3.0" value="1.0" step="0.1">
    </div>
    
    <button class="quantum-button" id="resetBtn">🔄 Reset</button>
  </div>
  
  <!-- Simple Stats -->
  <div id="quantum-stats">
    <div>Images: <span id="imageCount">0</span></div>
    <div>FPS: <span id="fps">0</span></div>
  </div>
  
  <!-- Simple Controls -->
  <div id="quantum-portal">
    <div>Click: Focus Image</div>
    <div>Arrow Keys: Navigate</div>
    <div>Space: Toggle Auto-rotate</div>
  </div>
  
  <!-- Quantum Counter -->
  <div id="quantum-counter">
    <span id="currentImage">1</span> / <span id="totalImages">5</span>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "/examples/js/vendor/three/build/three.module.js",
        "three/addons/": "/examples/js/vendor/three/examples/jsm/",
        "lil-gui": "/examples/js/vendor/lil-gui/dist/lil-gui.esm.js",
        "@sparkjsdev/spark": "/dist/spark.module.js"
      }
    }
  </script>
  <script type="module">
    import {
      dyno,
      SparkRenderer,
      SplatMesh,
      SparkControls,
      SplatEdit,
      SplatEditSdf,
      SplatEditSdfType,
      SplatEditRgbaBlendMode,
      FpsMovement,
      PointerControls,
      VRButton,
    } from "@sparkjsdev/spark";
    import * as THREE from "three";
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { GLTFExporter } from "three/addons/exporters/GLTFExporter.js";
    import { getAssetFileURL } from "/examples/js/get-asset-url.js";
    import { GUI } from "lil-gui";

    const splatFiles = [
      "penguin.spz",
      "dessert.spz", 
      "woobles.spz",
      "butterfly.spz",
      "cat.spz",
      "robot-head.spz",
      "fireplace.spz",
      "valley.spz",
      "snow-street.spz",
      "branzino-amarin.spz",
      "burger-from-amboy.spz",
      "clams-and-caviar-by-ikoyi.spz"
    ];
    
    // Fallback URLs in case asset loading fails
    const fallbackUrls = [
      "https://sparkjs.dev/assets/splats/penguin.spz",
      "https://sparkjs.dev/assets/splats/dessert.spz",
      "https://sparkjs.dev/assets/splats/woobles.spz",
      "https://sparkjs.dev/assets/splats/butterfly.spz",
      "https://sparkjs.dev/assets/splats/cat.spz",
      "https://sparkjs.dev/assets/splats/robot-head.spz",
      "https://sparkjs.dev/assets/splats/fireplace.spz",
      "https://sparkjs.dev/assets/splats/valley.spz",
      "https://sparkjs.dev/assets/splats/snow-street.spz",
      "https://sparkjs.dev/assets/splats/food/branzino-amarin.spz",
      "https://sparkjs.dev/assets/splats/food/burger-from-amboy.spz",
      "https://sparkjs.dev/assets/splats/food/clams-and-caviar-by-ikoyi.spz"
    ];
    const sceneFile = "dali-table.glb"
    // Background options - you can change these
    const backgroundOptions = {
      skyFile: "dali-env.glb", // 3D skybox
      backgroundColor: new THREE.Color(0x000000), // Solid color
      // Sky and nature background images
      imageBackgrounds: {
        sky: "https://sparkjs.dev/assets/images/sky.jpeg",
        space: "https://sparkjs.dev/assets/images/star.png",
        galaxy: "https://sparkjs.dev/assets/images/star.png",
        nebula: "https://sparkjs.dev/assets/images/star.png",
        aurora: "https://sparkjs.dev/assets/images/sky.jpeg",
        sunset: "https://sparkjs.dev/assets/images/sky.jpeg",
        ocean: "https://sparkjs.dev/assets/images/sky.jpeg",
        forest: "https://sparkjs.dev/assets/images/butterfly.png",
        mountains: "https://sparkjs.dev/assets/images/sky.jpeg"
      },
      gradientColors: {
        type1: [0x0a0a0a, 0x1a1a2e, 0x16213e, 0x0f3460], // Dark blue gradient
        type2: [0x1a1a2e, 0x16213e, 0x0f3460, 0x0a0a0a], // Blue to black
        type3: [0x2d1b69, 0x11998e, 0x38ef7d, 0x2d1b69], // Purple to green
        type4: [0xff6b9d, 0xff8ab3, 0xff5722, 0xf44336], // Pink to red
        type5: [0x00ffff, 0x0080ff, 0x0000ff, 0x8000ff], // Cyan to purple
      }
    };
    
    let currentBackgroundType = 'sky'; // 'skybox', 'solid', 'gradient1', 'gradient2', etc.

    // Quantum-inspired parameters
    const QUANTUM_PARAMS = {
      // Basic quantum parameters
      quantumSpeed: 1.0,
      speedMultiplier: 1.0,
      rotation: false,
      focalDistance: 5.0,
      apertureSize: 0.1,
      autoTransition: false,
      entanglementStrength: 0.5,
      waveFunction: 0.3,
      uncertainty: 0.7,
      quantumField: 0.4,
      
      // Quantum states
      quantumState: 'superposition',
              neuralStyle: 'vanGogh',
      morphingType: 'wave',
      
      // Quantum effects
      superpositionEnabled: true,
      entanglementEnabled: false,
      tunnelingEnabled: false,
      teleportationEnabled: false,
      interferenceEnabled: false,
      collapseEnabled: false,
      entropyEnabled: false,
      coherenceEnabled: false,
      decoherenceEnabled: false,
      measurementEnabled: false,
      
      // Neural style parameters
      styleStrength: 0.5,
      colorIntensity: 1.0,
      neuralSpeed: 1.0,
      particleCount: 2000,
      
      // Morphing parameters
      morphSpeed: 1.0,
      waveAmplitude: 0.5,
      waveFrequency: 2.0,
      colorShift: 0.3,
      distortionStrength: 0.8,
      morphPhase: 0.0,
      
      // Quantum field parameters
      fieldRadius: 3.0,
      fieldIntensity: 1.0,
      fieldColor: new THREE.Color(0x00ffff),
      fieldPulse: 0.5,
      
      // Entropy and chaos
      entropyLevel: 0.0,
      chaosFactor: 0.3,
      randomness: 0.5,
      
      // Performance
      pause: false,
      autoRotate: true,
      fullscreen: false,
    };

    // Quantum transition system inspired by splat-transitions but with quantum mechanics
    function getQuantumTransitionState(t, fadeInTime, fadeOutTime, period) {
      const dynoOne = dyno.dynoFloat(1.0);
      const wrapT = dyno.mod(t, period);
      const normT = dyno.mod(t, dynoOne);
      
      // Quantum superposition of states
      const isFadeIn = dyno.and(
        dyno.greaterThan(wrapT, fadeInTime),
        dyno.lessThan(wrapT, dyno.add(fadeInTime, dynoOne)),
      );
      const isFadeOut = dyno.and(
        dyno.greaterThan(wrapT, fadeOutTime),
        dyno.lessThan(wrapT, dyno.add(fadeOutTime, dynoOne)),
      );
      
      // Quantum entanglement between states
      const inTransition = dyno.or(isFadeIn, isFadeOut);
      const quantumPhase = dyno.mul(normT, dyno.dynoFloat(Math.PI * 2));
      
      return { inTransition, isFadeIn, normT, quantumPhase };
    }

    // Quantum contraction system with quantum mechanics effects
    function quantumContractionDyno() {
      return new dyno.Dyno({
        inTypes: {
          gsplat: dyno.Gsplat,
          inTransition: "bool",
          fadeIn: "bool",
          t: "float",
          quantumPhase: "float",
          splatScale: "float",
          entanglementStrength: "float",
          waveFunction: "float",
          uncertainty: "float",
          quantumField: "float",
        },
        outTypes: { gsplat: dyno.Gsplat },
        globals: () => [
          dyno.unindent(`
          // Quantum wave function
          vec3 applyQuantumCenter(vec3 center, float t, float phase, float waveFunc, float uncertainty) {
            // Quantum tunneling effect
            float tunnel = sin(phase * 3.0) * waveFunc * 0.5;
            
            // Uncertainty principle - position becomes more uncertain
            vec3 uncertaintyOffset = vec3(
              sin(phase + center.y * 2.0) * uncertainty * 0.3,
              cos(phase + center.z * 2.0) * uncertainty * 0.3,
              sin(phase + center.x * 2.0) * uncertainty * 0.3
            );
            
            // Quantum interference pattern
            float interference = sin(phase * 5.0 + length(center) * 3.0) * waveFunc * 0.2;
            
            return center + uncertaintyOffset + vec3(interference, interference * 0.5, interference * 0.3);
          }

          // Quantum scale with superposition
          vec3 applyQuantumScale(vec3 scales, float t, float targetScale, float entanglement) {
            // Quantum superposition of scales
            float superposedScale = targetScale * (1.0 + sin(t * 10.0) * entanglement * 0.3);
            vec3 targetScales = superposedScale * vec3(1.0, 1.0, 1.0);
            
            // Quantum fluctuation
            float fluctuation = sin(t * 20.0) * entanglement * 0.1;
            
            return mix(scales, targetScales, t) + vec3(fluctuation);
          }

          // Quantum opacity with wave collapse
          float applyQuantumOpacity(float opacity, float t, bool fadeIn, float quantumField) {
            // Wave function collapse
            float collapse = 1.0 - exp(-t * 3.0);
            
            if (fadeIn) {
              float quantumRise = sin(t * Math.PI) * quantumField;
              return mix(0.0, opacity, t + quantumRise * 0.2) * collapse;
            } else {
              float quantumDecay = cos(t * Math.PI) * quantumField;
              return mix(opacity, 0.0, t + quantumDecay * 0.2) * collapse;
            }
          }

          // Quantum color shift
          vec4 applyQuantumColor(vec4 color, float phase, float field) {
            // Quantum chromodynamics effect
            vec3 quantumShift = vec3(
              sin(phase) * field * 0.3,
              cos(phase * 0.7) * field * 0.2,
              sin(phase * 1.3) * field * 0.4
            );
            
            return vec4(color.rgb + quantumShift, color.a);
          }
          `)
        ],
        statements: ({ inputs, outputs }) => dyno.unindentLines(`
          ${outputs.gsplat} = ${inputs.gsplat};
          
          // Apply quantum effects
          ${outputs.gsplat}.center = applyQuantumCenter(
            ${inputs.gsplat}.center, 
            ${inputs.t}, 
            ${inputs.quantumPhase}, 
            ${inputs.waveFunction}, 
            ${inputs.uncertainty}
          );
          
          ${outputs.gsplat}.scales = applyQuantumScale(
            ${inputs.gsplat}.scales, 
            ${inputs.t}, 
            ${inputs.splatScale}, 
            ${inputs.entanglementStrength}
          );
          
          ${outputs.gsplat}.rgba = applyQuantumColor(
            ${inputs.gsplat}.rgba, 
            ${inputs.quantumPhase}, 
            ${inputs.quantumField}
          );
          
          if (${inputs.inTransition}) {
            ${outputs.gsplat}.rgba.a = applyQuantumOpacity(
              ${inputs.gsplat}.rgba.a, 
              ${inputs.t}, 
              ${inputs.fadeIn}, 
              ${inputs.quantumField}
            );
          } else {
            ${outputs.gsplat}.rgba.a = 0.0;
          }
        `),
      });
    }

    // Quantum modifier function
    function getQuantumModifier(
      inTransition,
      fadeIn,
      t,
      quantumPhase,
      splatScale,
      entanglementStrength,
      waveFunction,
      uncertainty,
      quantumField
    ) {
      const quantumContraction = quantumContractionDyno();
      return dyno.dynoBlock(
        { gsplat: dyno.Gsplat },
        { gsplat: dyno.Gsplat },
        ({ gsplat }) => {
          gsplat = quantumContraction.apply({
            gsplat, 
            inTransition, 
            fadeIn, 
            t, 
            quantumPhase,
            splatScale, 
            entanglementStrength,
            waveFunction,
            uncertainty,
            quantumField
          }).gsplat;
          return { gsplat };
        },
      );
    }
    
    // Neural style transfer system inspired by neural-style-transfer
    function createNeuralStyleDyno() {
      return new dyno.Dyno({
        inTypes: {
          gsplat: dyno.Gsplat,
          time: "float",
          styleStrength: "float",
          colorIntensity: "float",
          neuralSpeed: "float",
          styleType: "int",
        },
        outTypes: { gsplat: dyno.Gsplat },
        globals: () => [
          dyno.unindent(`
          // Van Gogh style
          vec4 applyVanGoghStyle(vec4 color, float time, float strength) {
            vec3 vanGogh = color.rgb + vec3(
              sin(time * 2.0 + color.r * 10.0) * strength * 0.3,
              cos(time * 1.5 + color.g * 8.0) * strength * 0.2,
              sin(time * 2.5 + color.b * 12.0) * strength * 0.4
            );
            return vec4(clamp(vanGogh, 0.0, 1.0), color.a);
          }
          
          // Monet style
          vec4 applyMonetStyle(vec4 color, float time, float strength) {
            vec3 monet = color.rgb + vec3(
              sin(time * 0.8) * strength * 0.2,
              cos(time * 1.2) * strength * 0.3,
              sin(time * 0.6) * strength * 0.1
            );
            return vec4(clamp(monet, 0.0, 1.0), color.a);
          }
          
          // Picasso style
          vec4 applyPicassoStyle(vec4 color, float time, float strength) {
            vec3 picasso = vec3(
              color.r + sin(time * 3.0) * strength * 0.4,
              color.g + cos(time * 2.5) * strength * 0.3,
              color.b + sin(time * 3.5) * strength * 0.5
            );
            return vec4(clamp(picasso, 0.0, 1.0), color.a);
          }
          
          // Kandinsky style
          vec4 applyKandinskyStyle(vec4 color, float time, float strength) {
            vec3 kandinsky = color.rgb + vec3(
              sin(time * 4.0 + color.r * 5.0) * strength * 0.5,
              cos(time * 3.5 + color.g * 6.0) * strength * 0.4,
              sin(time * 4.5 + color.b * 7.0) * strength * 0.6
            );
            return vec4(clamp(kandinsky, 0.0, 1.0), color.a);
          }
          
          // Hokusai style
          vec4 applyHokusaiStyle(vec4 color, float time, float strength) {
            vec3 hokusai = color.rgb + vec3(
              sin(time * 1.5) * strength * 0.2,
              cos(time * 1.8) * strength * 0.3,
              sin(time * 1.2) * strength * 0.1
            );
            return vec4(clamp(hokusai, 0.0, 1.0), color.a);
          }
          
          // Warhol style
          vec4 applyWarholStyle(vec4 color, float time, float strength) {
            vec3 warhol = vec3(
              color.r + sin(time * 5.0) * strength * 0.6,
              color.g + cos(time * 4.5) * strength * 0.5,
              color.b + sin(time * 5.5) * strength * 0.7
            );
            return vec4(clamp(warhol, 0.0, 1.0), color.a);
          }
          
          // Dali style
          vec4 applyDaliStyle(vec4 color, float time, float strength) {
            vec3 dali = color.rgb + vec3(
              sin(time * 2.5 + color.r * 15.0) * strength * 0.4,
              cos(time * 2.0 + color.g * 12.0) * strength * 0.3,
              sin(time * 3.0 + color.b * 18.0) * strength * 0.5
            );
            return vec4(clamp(dali, 0.0, 1.0), color.a);
          }
          `)
        ],
        statements: ({ inputs, outputs }) => dyno.unindentLines(`
          ${outputs.gsplat} = ${inputs.gsplat};
          
          // Apply neural style based on type
          if (${inputs.styleType} == 0) {
            ${outputs.gsplat}.rgba = applyVanGoghStyle(${inputs.gsplat}.rgba, ${inputs.time}, ${inputs.styleStrength});
          } else if (${inputs.styleType} == 1) {
            ${outputs.gsplat}.rgba = applyMonetStyle(${inputs.gsplat}.rgba, ${inputs.time}, ${inputs.styleStrength});
          } else if (${inputs.styleType} == 2) {
            ${outputs.gsplat}.rgba = applyPicassoStyle(${inputs.gsplat}.rgba, ${inputs.time}, ${inputs.styleStrength});
          } else if (${inputs.styleType} == 3) {
            ${outputs.gsplat}.rgba = applyKandinskyStyle(${inputs.gsplat}.rgba, ${inputs.time}, ${inputs.styleStrength});
          } else if (${inputs.styleType} == 4) {
            ${outputs.gsplat}.rgba = applyHokusaiStyle(${inputs.gsplat}.rgba, ${inputs.time}, ${inputs.styleStrength});
          } else if (${inputs.styleType} == 5) {
            ${outputs.gsplat}.rgba = applyWarholStyle(${inputs.gsplat}.rgba, ${inputs.time}, ${inputs.styleStrength});
          } else {
            ${outputs.gsplat}.rgba = applyDaliStyle(${inputs.gsplat}.rgba, ${inputs.time}, ${inputs.styleStrength});
          }
          
          // Apply color intensity
          ${outputs.gsplat}.rgba.rgb *= ${inputs.colorIntensity};
        `),
      });
    }

    // Quantum morphable splat mesh with neural style and morphing
    async function quantumMorphableSplatMesh(
      assetName,
      time,
      fadeInTime,
      fadeOutTime,
      period,
      splatCoverage,
      entanglementStrength,
      waveFunction,
      uncertainty,
      quantumField
    ) {
      console.log(`🌌 Loading quantum asset: ${assetName}`);
      
      // Add timeout to prevent infinite loading
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Loading timeout')), 10000);
      });
      
      try {
        let url = await Promise.race([
          getAssetFileURL(assetName),
          timeoutPromise
        ]);
        
        if (!url) {
          const fallbackIndex = splatFiles.indexOf(assetName);
          if (fallbackIndex >= 0) {
            url = fallbackUrls[fallbackIndex];
            console.log(`⚛️ Using quantum fallback: ${url}`);
          } else {
            console.error(`❌ No quantum fallback for: ${assetName}`);
            return null;
          }
        }
      
      try {
        const splatMesh = new SplatMesh({
          url: url,
          onFrame: ({ mesh, time }) => {
            mesh.needsUpdate = true;
          }
        });
        
        await splatMesh.initialized;
        console.log(`🌌 Quantum mesh initialized. Splat count: ${splatMesh.packedSplats.numSplats}`);
        
        const splatScale = dyno.div(
          dyno.mul(dyno.dynoFloat(splatCoverage), dyno.dynoFloat(1.0)),
          dyno.dynoFloat(splatMesh.packedSplats.numSplats / 1000.0)
        );

        const { inTransition, isFadeIn, normT, quantumPhase } =
          getQuantumTransitionState(time, fadeInTime, fadeOutTime, period);

        // Apply quantum modifier
        splatMesh.worldModifier = getQuantumModifier(
          inTransition,
          isFadeIn,
          normT,
          quantumPhase,
          splatScale,
          dyno.dynoFloat(entanglementStrength),
          dyno.dynoFloat(waveFunction),
          dyno.dynoFloat(uncertainty),
          dyno.dynoFloat(quantumField)
        );
        
        splatMesh.updateGenerator();
        console.log(`🌌 Quantum mesh created:`, splatMesh);
        return splatMesh;
      } catch (error) {
        console.error(`❌ Quantum error for ${assetName}:`, error);
        return null;
      }
    } catch (error) {
      console.error(`❌ Asset loading error for ${assetName}:`, error);
      return null;
    }
    }

    async function loadDelitGLB(filename, isEnv = false) {
      const url = await getAssetFileURL(filename);
      console.log("Loading GLB", url);
      const gltfLoader = new GLTFLoader();
      const gltf = await new Promise((resolve, reject) => {
        gltfLoader.load(url, resolve, undefined, reject);
      });
      const scene = gltf.scene;
      // Switch all materials to albedo slot
      scene.traverse((child) => {
        if (child.isMesh && child.material) {
          const originalMaterial = child.material;
          const basicMaterial = new THREE.MeshBasicMaterial();
          if (originalMaterial.color) {
            basicMaterial.color.copy(originalMaterial.color);
          }
          if (originalMaterial.map) {
            basicMaterial.map = originalMaterial.map;
          }
          if (isEnv) { // sky sphere handling
            basicMaterial.side = THREE.BackSide;
            basicMaterial.map.mapping = THREE.EquirectangularReflectionMapping;
            basicMaterial.map.colorSpace = THREE.LinearSRGBColorSpace;
            basicMaterial.map.needsUpdate = true;
          }
          child.material = basicMaterial;
        }
      });
      return scene;
    }


    const canvas = document.getElementById("canvas");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
    renderer.setClearColor(new THREE.Color(0x000000), 1);

    const scene = new THREE.Scene();
    const spark = new SparkRenderer({
      renderer,
      apertureAngle: 0.02,
      focalDistance: 5.0,
    });
    scene.add(spark);

    const camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.01,
      1000,
    );
    camera.position.set(0, 0, 10); // Move camera back to see images
    camera.lookAt(0, 0, 0);
    scene.add(camera);

    const orbitControls = new OrbitControls(camera, renderer.domElement);
    orbitControls.target.set(0, 0, 0); // Look at center
    function handleResize() {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      renderer.setSize(width, height, false);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }

    handleResize();
    window.addEventListener("resize", handleResize);

    const time = dyno.dynoFloat(0.0);
    
    // Gallery functionality variables - IMAGE FOCUSED ONLY
    let currentFocusedImage = 0;
    let splatMeshes = [];
    let galleryMode = 'carousel'; // carousel, grid, spiral, wave, focus, morph
    let isTransitioning = false;
    let transitionProgress = 0;
    let morphProgress = 0;
    let waveOffset = 0;
    let spiralAngle = 0;

    // Unique gallery layouts inspired by multiple examples
    const galleryLayouts = {
      carousel: {
        positions: [
          new THREE.Vector3(-6, 0, 0),
          new THREE.Vector3(-3, 0, 0),
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(3, 0, 0),
          new THREE.Vector3(6, 0, 0)
        ],
        scales: [0.3, 0.4, 0.6, 0.4, 0.3],
        spacing: 3,
        description: "Horizontal carousel with center focus"
      },
      grid: {
        positions: [
          new THREE.Vector3(-4, 2, 0),
          new THREE.Vector3(0, 2, 0),
          new THREE.Vector3(4, 2, 0),
          new THREE.Vector3(-4, 0, 0),
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(4, 0, 0),
          new THREE.Vector3(-4, -2, 0),
          new THREE.Vector3(0, -2, 0),
          new THREE.Vector3(4, -2, 0)
        ],
        scales: [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3],
        spacing: 4,
        description: "3x3 organized grid layout"
      },
      spiral: {
        positions: [
          new THREE.Vector3(-3, 3, 0),
          new THREE.Vector3(3, 2, 0),
          new THREE.Vector3(2, -2, 0),
          new THREE.Vector3(-2, -3, 0),
          new THREE.Vector3(-4, 0, 0),
          new THREE.Vector3(0, 0, 0)
        ],
        scales: [0.4, 0.4, 0.4, 0.4, 0.4, 0.4],
        spacing: 3,
        description: "Spiral arrangement with rotation"
      },
      galaxy: {
        positions: [
          new THREE.Vector3(-5, 2, 0),
          new THREE.Vector3(5, -2, 0),
          new THREE.Vector3(0, 3, 0),
          new THREE.Vector3(-3, -3, 0),
          new THREE.Vector3(3, 3, 0),
          new THREE.Vector3(-1, 4, 0),
          new THREE.Vector3(1, -4, 0),
          new THREE.Vector3(-4, 1, 0),
          new THREE.Vector3(4, -1, 0)
        ],
        scales: [0.3, 0.3, 0.4, 0.3, 0.3, 0.25, 0.25, 0.25, 0.25],
        spacing: 4,
        description: "Galaxy-like scattered arrangement"
      },
      pyramid: {
        positions: [
          new THREE.Vector3(0, 4, 0),
          new THREE.Vector3(-2, 2, 0),
          new THREE.Vector3(2, 2, 0),
          new THREE.Vector3(-3, 0, 0),
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(3, 0, 0),
          new THREE.Vector3(-4, -2, 0),
          new THREE.Vector3(-1, -2, 0),
          new THREE.Vector3(1, -2, 0),
          new THREE.Vector3(4, -2, 0)
        ],
        scales: [0.5, 0.4, 0.4, 0.35, 0.4, 0.35, 0.3, 0.3, 0.3, 0.3],
        spacing: 2,
        description: "Pyramid arrangement with focus at top"
      },
      wave: {
        positions: [
          new THREE.Vector3(-6, 0, 0),
          new THREE.Vector3(-4, 1, 0),
          new THREE.Vector3(-2, -1, 0),
          new THREE.Vector3(0, 1, 0),
          new THREE.Vector3(2, -1, 0),
          new THREE.Vector3(4, 1, 0),
          new THREE.Vector3(6, -1, 0)
        ],
        scales: [0.3, 0.35, 0.35, 0.4, 0.35, 0.35, 0.3],
        spacing: 2,
        description: "Wave-like floating motion"
      },
      focus: {
        positions: [
          new THREE.Vector3(-4, 0, 0),
          new THREE.Vector3(4, 0, 0),
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(-2, 2, 0),
          new THREE.Vector3(2, 2, 0),
          new THREE.Vector3(-2, -2, 0),
          new THREE.Vector3(2, -2, 0)
        ],
        scales: [0.3, 0.3, 0.6, 0.25, 0.25, 0.25, 0.25],
        spacing: 3,
        description: "Center focus with depth emphasis"
      },
      morph: {
        positions: [
          new THREE.Vector3(-3, 0, 0),
          new THREE.Vector3(3, 0, 0),
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(-1.5, 2, 0),
          new THREE.Vector3(1.5, 2, 0),
          new THREE.Vector3(-1.5, -2, 0),
          new THREE.Vector3(1.5, -2, 0)
        ],
        scales: [0.4, 0.4, 0.5, 0.3, 0.3, 0.3, 0.3],
        spacing: 2,
        description: "Morphing transitions between images"
      },
      dreamscape: {
        positions: [
          new THREE.Vector3(-5, 3, 0),
          new THREE.Vector3(5, -3, 0),
          new THREE.Vector3(0, 4, 0),
          new THREE.Vector3(-4, -2, 0),
          new THREE.Vector3(4, 2, 0),
          new THREE.Vector3(-2, 5, 0),
          new THREE.Vector3(2, -5, 0),
          new THREE.Vector3(-6, 0, 0),
          new THREE.Vector3(6, 0, 0)
        ],
        scales: [0.35, 0.35, 0.45, 0.3, 0.3, 0.25, 0.25, 0.25, 0.25],
        spacing: 4,
        description: "Dreamscape portal arrangement"
      },
      neural: {
        positions: [
          new THREE.Vector3(-4, 2, 0),
          new THREE.Vector3(4, 2, 0),
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(-4, -2, 0),
          new THREE.Vector3(4, -2, 0),
          new THREE.Vector3(-2, 3, 0),
          new THREE.Vector3(2, 3, 0),
          new THREE.Vector3(-2, -3, 0),
          new THREE.Vector3(2, -3, 0)
        ],
        scales: [0.35, 0.35, 0.5, 0.35, 0.35, 0.25, 0.25, 0.25, 0.25],
        spacing: 3,
        description: "Neural network node arrangement"
      },
      cosmic: {
        positions: [
          new THREE.Vector3(-6, 0, 0),
          new THREE.Vector3(6, 0, 0),
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(-3, 3, 0),
          new THREE.Vector3(3, 3, 0),
          new THREE.Vector3(-3, -3, 0),
          new THREE.Vector3(3, -3, 0),
          new THREE.Vector3(0, 4, 0),
          new THREE.Vector3(0, -4, 0)
        ],
        scales: [0.3, 0.3, 0.5, 0.25, 0.25, 0.25, 0.25, 0.2, 0.2],
        spacing: 4,
        description: "Cosmic field arrangement"
      }
    };

    // Quantum State Management System
    class QuantumGalleryState {
      constructor() {
        // Quantum states
        this.quantumState = 'superposition';
        this.currentImageIndex = 0;
        this.entangledImages = [];
        this.quantumPhase = 0;
        this.entropy = 0;
        this.coherence = 1.0;
        
        // Quantum effects
        this.superpositionEnabled = true;
        this.entanglementEnabled = false;
        this.tunnelingEnabled = false;
        this.teleportationEnabled = false;
        this.interferenceEnabled = false;
        this.collapseEnabled = false;
        this.measurementEnabled = false;
        
        // Neural style state
        this.neuralStyleActive = false;
        this.currentStyle = 'van-gogh';
        this.styleIntensity = 0.5;
        
        // Morphing state
        this.morphingActive = false;
        this.morphingType = 'wave';
        this.morphingProgress = 0;
        
        // Quantum field
        this.quantumFieldActive = false;
        this.fieldRadius = 3.0;
        this.fieldIntensity = 1.0;
        
        // Performance tracking
        this.fps = 0;
        this.memoryUsage = 0;
        this.particleCount = 0;
        
        // Animation state
        this.isTransitioning = false;
        this.transitionTime = 0;
        this.transitionDuration = 2.0;
        this.autoRotate = true;
        this.autoRotateSpeed = 0.5;
        this.rotationSpeed = 0.5;
        
        // Gallery effects
        this.gentleFloat = false;
        this.floatSpeed = 1.0;
        this.floatAmplitude = 0.1;
        
        // Manual transitions
        this.manualTransitionActive = false;
        this.manualTransitionProgress = 0.0;
        this.manualTransitionDuration = 2.0;
        this.manualTransitionEasing = 'easeInOut';
        
        // Image effects
        this.imageBreathing = false;
        this.breathingSpeed = 2.0;
        this.breathingAmplitude = 0.05;
        
        this.imagePulse = false;
        this.pulseSpeed = 3.0;
        this.pulseIntensity = 0.1;
        
        this.imageTilt = false;
        this.tiltSpeed = 1.5;
        this.tiltAmount = 0.1;
        
        this.imageGlow = false;
        this.glowIntensity = 0.2;
        
        this.imageShake = false;
        this.shakeIntensity = 0.02;
        
        this.imageZoom = false;
        this.zoomSpeed = 2.0;
        this.zoomRange = 0.1;
        
        this.imageWobble = false;
        this.wobbleSpeed = 2.5;
        this.wobbleAmount = 0.05;
        
        this.imageSpin = false;
        this.spinSpeed = 1.0;
        
        this.imageBounce = false;
        this.bounceSpeed = 3.0;
        this.bounceHeight = 0.1;
        
        this.imageFade = false;
        this.fadeSpeed = 1.5;
        
        this.imageScale = false;
        this.scaleSpeed = 2.0;
        this.scaleRange = 0.1;
        
        // Advanced effects
        this.morphingEnabled = false;
        this.morphingSpeed = 1.0;
        this.morphingIntensity = 0.5;
        
        this.colorShiftEnabled = false;
        this.colorShiftSpeed = 2.0;
        this.colorShiftAmount = 0.3;
        
        this.distortionEnabled = false;
        this.distortionSpeed = 1.5;
        this.distortionAmount = 0.2;
        
        this.waveEffectEnabled = false;
        this.waveSpeed = 2.0;
        this.waveAmplitude = 0.1;
        
        this.rippleEffectEnabled = false;
        this.rippleSpeed = 1.0;
        this.rippleRadius = 2.0;
        
        this.glowEffectEnabled = false;
        this.glowIntensity = 0.3;
        
        // Interactive effects
        this.audioReactiveEnabled = false;
        this.audioFrequency = 2.0;
        this.audioAmplitude = 0.2;
        
        this.physicsEnabled = false;
        this.gravity = 0.1;
        this.bounce = 0.8;
        this.friction = 0.95;
        
        this.multiViewEnabled = false;
        this.viewCount = 4;
        this.viewSpacing = 2.0;
        
        this.proceduralEnabled = false;
        this.proceduralSpeed = 1.0;
        this.proceduralComplexity = 0.5;
        
        this.textureEffectEnabled = false;
        this.textureSpeed = 2.0;
        this.textureIntensity = 0.3;
        
        // Mouse interaction
        this.clickEffectEnabled = true;
        this.mouseInteractionEnabled = true;
        this.dragEnabled = true;
        this.dragSensitivity = 1.0;
        this.hoverEffectEnabled = true;
        
        // Focus state
        this.focusedIndex = 0;
        this.currentMode = 'superposition';
        
        // Quantum chaos
        this.chaosFactor = 0.3;
        this.randomness = 0.5;
        this.quantumNoise = 0.1;
        
        // Interactive state
        this.mousePosition = new THREE.Vector2();
        this.isMouseDown = false;
        this.dragStart = new THREE.Vector2();
        this.lastClickTime = 0;
        
        // Audio state
        this.audioContext = null;
        this.analyser = null;
        this.microphone = null;
        this.audioData = new Uint8Array(128);
        this.audioReactive = false;
        
        // Physics state
        this.physicsEnabled = false;
        this.gravity = 0.1;
        this.particles = [];
        this.explosions = [];
        
        // Quantum layouts
        this.quantumLayouts = {
          superposition: {
            positions: [
              new THREE.Vector3(-4, 2, 0),
              new THREE.Vector3(4, 2, 0),
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(-4, -2, 0),
              new THREE.Vector3(4, -2, 0),
              new THREE.Vector3(-2, 3, 0),
              new THREE.Vector3(2, 3, 0),
              new THREE.Vector3(-2, -3, 0),
              new THREE.Vector3(2, -3, 0)
            ],
            scales: [0.4, 0.4, 0.6, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3],
            description: "Quantum superposition of all states"
          },
          entanglement: {
            positions: [
              new THREE.Vector3(-3, 0, 0),
              new THREE.Vector3(3, 0, 0),
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(-1.5, 2, 0),
              new THREE.Vector3(1.5, 2, 0),
              new THREE.Vector3(-1.5, -2, 0),
              new THREE.Vector3(1.5, -2, 0)
            ],
            scales: [0.5, 0.5, 0.7, 0.4, 0.4, 0.4, 0.4],
            description: "Entangled quantum states"
          },
          tunneling: {
            positions: [
              new THREE.Vector3(-6, 0, 0),
              new THREE.Vector3(6, 0, 0),
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(-3, 3, 0),
              new THREE.Vector3(3, 3, 0),
              new THREE.Vector3(-3, -3, 0),
              new THREE.Vector3(3, -3, 0)
            ],
            scales: [0.3, 0.3, 0.8, 0.3, 0.3, 0.3, 0.3],
            description: "Quantum tunneling through barriers"
          },
          teleportation: {
            positions: [
              new THREE.Vector3(-5, 3, 0),
              new THREE.Vector3(5, -3, 0),
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(-4, -2, 0),
              new THREE.Vector3(4, 2, 0),
              new THREE.Vector3(-2, 4, 0),
              new THREE.Vector3(2, -4, 0)
            ],
            scales: [0.4, 0.4, 0.6, 0.3, 0.3, 0.3, 0.3],
            description: "Quantum teleportation network"
          },
          interference: {
            positions: [
              new THREE.Vector3(-4, 2, 0),
              new THREE.Vector3(4, 2, 0),
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(-4, -2, 0),
              new THREE.Vector3(4, -2, 0),
              new THREE.Vector3(-2, 3, 0),
              new THREE.Vector3(2, 3, 0),
              new THREE.Vector3(-2, -3, 0),
              new THREE.Vector3(2, -3, 0)
            ],
            scales: [0.35, 0.35, 0.5, 0.35, 0.35, 0.25, 0.25, 0.25, 0.25],
            description: "Quantum interference patterns"
          }
        };
      }

      update(deltaTime) {
        // Update quantum phase
        this.quantumPhase += deltaTime * QUANTUM_PARAMS.quantumSpeed;
        
        // Update entropy
        this.entropy += deltaTime * QUANTUM_PARAMS.entropyLevel;
        this.entropy = Math.min(this.entropy, 1.0);
        
        // Update coherence
        this.coherence = Math.max(0.0, 1.0 - this.entropy);
        
        // Update transition
        if (this.isTransitioning) {
          this.transitionTime += deltaTime;
          if (this.transitionTime >= this.transitionDuration) {
            this.isTransitioning = false;
            this.transitionTime = this.transitionDuration;
          }
        }
        
        // Update morphing
        if (this.morphingActive) {
          this.morphingProgress += deltaTime * QUANTUM_PARAMS.morphSpeed;
          if (this.morphingProgress >= 1.0) {
            this.morphingProgress = 0;
          }
        }
        
        // Update quantum noise
        this.quantumNoise = Math.sin(this.quantumPhase * 10) * QUANTUM_PARAMS.randomness;
      }

      getTransitionProgress() {
        return this.isTransitioning ? this.transitionTime / this.transitionDuration : 1.0;
      }

      startTransition() {
        this.isTransitioning = true;
        this.transitionTime = 0;
      }

      setQuantumState(state) {
        this.quantumState = state;
        this.startTransition();
        console.log(`🌌 Quantum state changed to: ${state}`);
      }

      toggleNeuralStyle() {
        this.neuralStyleActive = !this.neuralStyleActive;
        console.log(`🧠 Neural style ${this.neuralStyleActive ? 'activated' : 'deactivated'}`);
      }

      toggleMorphing() {
        this.morphingActive = !this.morphingActive;
        console.log(`🌀 Morphing ${this.morphingActive ? 'activated' : 'deactivated'}`);
      }

      toggleQuantumField() {
        this.quantumFieldActive = !this.quantumFieldActive;
        console.log(`⚛️ Quantum field ${this.quantumFieldActive ? 'activated' : 'deactivated'}`);
      }
    }

    const quantumState = new QuantumGalleryState();

    // Quantum layout system
    function updateQuantumLayout() {
      const layout = quantumState.quantumLayouts[quantumState.quantumState];
      const progress = quantumState.getTransitionProgress();
      
      splatMeshes.forEach((splatMesh, index) => {
        if (index < layout.positions.length) {
          const targetPos = layout.positions[index];
          const targetScale = layout.scales[index];
          
          // Quantum transition with uncertainty
          if (quantumState.isTransitioning) {
            const startPos = splatMesh.userData.originalPosition || splatMesh.position.clone();
            const uncertainty = QUANTUM_PARAMS.uncertainty * 0.5;
            const quantumOffset = new THREE.Vector3(
              (Math.random() - 0.5) * uncertainty,
              (Math.random() - 0.5) * uncertainty,
              (Math.random() - 0.5) * uncertainty
            );
            
            splatMesh.position.lerpVectors(startPos, targetPos.clone().add(quantumOffset), progress);
            const currentScale = splatMesh.userData.originalScale || 0.4;
            const newScale = currentScale + (targetScale - currentScale) * progress;
            splatMesh.scale.setScalar(newScale);
          } else {
            splatMesh.position.copy(targetPos);
            splatMesh.scale.setScalar(targetScale);
            splatMesh.userData.originalPosition = targetPos.clone();
            splatMesh.userData.originalScale = targetScale;
          }
          
                  // Apply quantum state-specific behaviors (disabled for focus testing)
        // applyQuantumBehavior(splatMesh, index);
        }
      });
    }
    
    // Apply quantum behavior based on current state
    function applyQuantumBehavior(splatMesh, index) {
      const time = Date.now() * 0.001;
      const phase = quantumState.quantumPhase + index * Math.PI * 0.5;
      
      switch(quantumState.quantumState) {
        case 'superposition':
          // Superposition: multiple states simultaneously
          const superposedScale = 1.0 + Math.sin(phase * 3) * 0.2;
          splatMesh.scale.setScalar(splatMesh.userData.originalScale * superposedScale);
          splatMesh.rotation.y += 0.01;
          break;
          
        case 'entanglement':
          // Entanglement: correlated behavior
          const entangledOffset = Math.sin(phase * 2) * 0.1;
          splatMesh.position.x += entangledOffset;
          splatMesh.position.y += Math.cos(phase * 2) * 0.1;
          break;
          
        case 'tunneling':
          // Tunneling: sudden position changes
          const tunnel = Math.sin(phase * 5) * 0.3;
          splatMesh.position.z += tunnel;
          splatMesh.scale.setScalar(splatMesh.userData.originalScale * (1.0 + Math.abs(tunnel) * 0.5));
          break;
          
        case 'teleportation':
          // Teleportation: instant position swaps
          const teleport = Math.sin(phase * 7) * 0.2;
          splatMesh.position.x += teleport;
          splatMesh.position.y += Math.cos(phase * 7) * 0.2;
          break;
          
        case 'interference':
          // Interference: wave-like patterns
          const interference = Math.sin(phase * 4 + index * 0.5) * 0.15;
          splatMesh.position.y += interference;
          splatMesh.rotation.z = interference * 0.5;
          break;
      }
    }

    // Quantum effects system
    function applyQuantumEffects(splatMesh, index, deltaTime) {
      const time = Date.now() * 0.001;
      const phase = quantumState.quantumPhase + index * Math.PI * 0.3;
      
      // Always apply neural style effects
      applyNeuralStyleEffect(splatMesh, time, index);
      
      // Always apply morphing effects
      applyMorphingEffect(splatMesh, time, index);
      
      // Apply breathing effect (disabled for focus testing)
      // const breathing = Math.sin(time * 2 + phase) * 0.1;
      // const baseScale = splatMesh.userData.originalScale || 0.6;
      // const focusMultiplier = splatMesh.userData.isFocused ? 1.5 : 1.0;
      // splatMesh.scale.setScalar((baseScale + breathing) * focusMultiplier);
      
              // Apply gentle rotation (disabled for focus testing)
        // splatMesh.rotation.y += deltaTime * 0.3;
        // splatMesh.rotation.x += deltaTime * 0.1;
        
        // Apply quantum field effects (disabled for focus testing)
        // const fieldStrength = Math.sin(time * 3 + phase) * 0.2;
        // splatMesh.position.y += Math.sin(time * 4 + phase) * 0.01;
        // splatMesh.position.x += Math.cos(time * 5 + phase) * 0.01;
        
        // Apply color shifting (disabled for focus testing)
        // if (splatMesh.material) {
        //   const colorShift = Math.sin(time * 6 + phase) * 0.1;
        //   splatMesh.material.color.setHSL(0.5 + colorShift, 0.8, 0.6);
        // }
      
      // Quantum field effects
      if (quantumState.quantumFieldActive) {
        applyQuantumFieldEffect(splatMesh, time, index);
      }
      
      // Audio reactive effects
      if (quantumState.audioReactive) {
        applyAudioReactiveEffect(splatMesh, index);
      }
      
      // Physics effects
      if (quantumState.physicsEnabled) {
        applyPhysicsEffect(splatMesh, deltaTime);
      }
      
      // Quantum noise
      const noise = quantumState.quantumNoise * 0.1;
      splatMesh.position.x += (Math.random() - 0.5) * noise;
      splatMesh.position.y += (Math.random() - 0.5) * noise;
    }
    
    // Neural style effects
    function applyNeuralStyleEffect(splatMesh, time, index) {
      const styleType = getStyleTypeIndex(quantumState.currentStyle);
      const neuralDyno = createNeuralStyleDyno();
      
      // Apply neural style through world modifier
      splatMesh.worldModifier = dyno.dynoBlock(
        { gsplat: dyno.Gsplat },
        { gsplat: dyno.Gsplat },
        ({ gsplat }) => {
          gsplat = neuralDyno.apply({
            gsplat,
            time: dyno.dynoFloat(time),
            styleStrength: dyno.dynoFloat(QUANTUM_PARAMS.styleStrength),
            colorIntensity: dyno.dynoFloat(QUANTUM_PARAMS.colorIntensity),
            neuralSpeed: dyno.dynoFloat(QUANTUM_PARAMS.neuralSpeed),
            styleType: dyno.dynoInt(styleType)
          }).gsplat;
          return { gsplat };
        }
      );
      splatMesh.updateGenerator();
    }
    
    // Morphing effects
    function applyMorphingEffect(splatMesh, time, index) {
      const morphProgress = quantumState.morphingProgress;
      const morphType = quantumState.morphingType;
      
      switch(morphType) {
        case 'wave':
          const waveOffset = Math.sin(time * 2 + index) * QUANTUM_PARAMS.waveAmplitude;
          splatMesh.position.y += waveOffset;
          splatMesh.rotation.z = waveOffset * 0.3;
          break;
        case 'spiral':
          const spiralAngle = time * 3 + index * Math.PI * 0.5;
          const spiralRadius = 0.5 + Math.sin(time) * 0.2;
          splatMesh.position.x += Math.cos(spiralAngle) * spiralRadius * 0.1;
          splatMesh.position.y += Math.sin(spiralAngle) * spiralRadius * 0.1;
          break;
        case 'explosion':
          const explosion = Math.sin(time * 4 + index) * QUANTUM_PARAMS.distortionStrength;
          splatMesh.scale.setScalar(splatMesh.userData.originalScale * (1.0 + explosion * 0.3));
          break;
      }
    }
    
    // Quantum field effects
    function applyQuantumFieldEffect(splatMesh, time, index) {
      const distance = splatMesh.position.length();
      const fieldStrength = Math.max(0, 1 - distance / quantumState.fieldRadius);
      const pulse = Math.sin(time * 3) * QUANTUM_PARAMS.fieldPulse;
      
      splatMesh.scale.setScalar(splatMesh.userData.originalScale * (1.0 + fieldStrength * pulse * 0.2));
      splatMesh.rotation.y += fieldStrength * 0.02;
    }
    
    // Audio reactive effects
    function applyAudioReactiveEffect(splatMesh, index) {
      if (quantumState.audioData && quantumState.audioData[index % quantumState.audioData.length]) {
        const audioLevel = quantumState.audioData[index % quantumState.audioData.length] / 255;
        splatMesh.scale.setScalar(splatMesh.userData.originalScale * (1.0 + audioLevel * 0.5));
        splatMesh.position.z += audioLevel * 0.3;
      }
    }
    
    // Physics effects
    function applyPhysicsEffect(splatMesh, deltaTime) {
      if (!splatMesh.userData.velocity) {
        splatMesh.userData.velocity = new THREE.Vector3(0, 0, 0);
      }
      
      // Apply gravity
      splatMesh.userData.velocity.y -= quantumState.gravity * deltaTime;
      
      // Update position
      splatMesh.position.add(splatMesh.userData.velocity.clone().multiplyScalar(deltaTime));
      
      // Bounce off ground
      if (splatMesh.position.y < -3) {
        splatMesh.position.y = -3;
        splatMesh.userData.velocity.y *= -0.8;
      }
      
      // Apply friction
      splatMesh.userData.velocity.multiplyScalar(0.95);
    }
    
    // Helper function to get style type index
    function getStyleTypeIndex(style) {
      const styles = ['van-gogh', 'monet', 'picasso', 'kandinsky', 'hokusai', 'warhol', 'dali'];
      return styles.indexOf(style);
    }

    // Gentle floating animation - IMAGES ONLY
    function updateGentleFloating(deltaTime) {
      if (!quantumState.gentleFloat) return;
      
      splatMeshes.forEach((splatMesh, index) => {
        const time = Date.now() * 0.001 * quantumState.floatSpeed;
        const offset = index * Math.PI * 0.5;
        
        // Very gentle floating
                  const floatY = Math.sin(time + offset) * quantumState.floatAmplitude * 0.1;
          const floatX = Math.cos(time + offset * 0.7) * quantumState.floatAmplitude * 0.05;
        
        splatMesh.position.y += floatY * deltaTime;
        splatMesh.position.x += floatX * deltaTime;
        
        // Very gentle rotation
        splatMesh.rotation.y += deltaTime * 0.1;
      });
    }

    // Manual transition system
    function startManualTransition() {
      quantumState.manualTransitionActive = true;
      quantumState.manualTransitionProgress = 0.0;
      console.log("Manual transition started");
    }

    function updateManualTransition(deltaTime) {
      if (quantumState.manualTransitionActive) {
        quantumState.manualTransitionProgress += deltaTime / quantumState.manualTransitionDuration;
        
        if (quantumState.manualTransitionProgress >= 1.0) {
          quantumState.manualTransitionActive = false;
          quantumState.manualTransitionProgress = 1.0;
          console.log("Manual transition completed");
        }
      }
    }

    function getManualTransitionProgress() {
      if (!quantumState.manualTransitionActive) return 1.0;
      
      const progress = quantumState.manualTransitionProgress;
      switch (quantumState.manualTransitionEasing) {
        case 'easeInOut':
          return progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        case 'easeIn':
          return progress * progress;
        case 'easeOut':
          return 1 - Math.pow(1 - progress, 2);
        default:
          return progress;
      }
    }

    // Advanced transition system inspired by splat-transitions
    function getTransitionState(t, fadeInTime, fadeOutTime, period) {
      const dynoOne = dyno.dynoFloat(1.0);
      const wrapT = dyno.mod(t, period);
      const normT = dyno.mod(t, dynoOne);
      const isFadeIn = dyno.and(
        dyno.greaterThan(wrapT, fadeInTime),
        dyno.lessThan(wrapT, dyno.add(fadeInTime, dynoOne)),
      );
      const isFadeOut = dyno.and(
        dyno.greaterThan(wrapT, fadeOutTime),
        dyno.lessThan(wrapT, dyno.add(fadeOutTime, dynoOne)),
      );
      const inTransition = dyno.or(isFadeIn, isFadeOut);
      return { inTransition, isFadeIn, normT };
    }

    function createAdvancedTransitionDyno() {
      return new dyno.Dyno({
        inTypes: {
          gsplat: dyno.Gsplat,
          inTransition: "bool",
          fadeIn: "bool",
          t: "float",
          splatScale: "float",
          focusRadius: "float",
          focusHeight: "float",
          isFocused: "bool",
        },
        outTypes: { gsplat: dyno.Gsplat },
        globals: () => [
          dyno.unindent(`
          vec3 applyFocusCenter(vec3 center, float t, float focusRadius, float focusHeight, bool isFocused) {
            if (!isFocused) {
              return center;
            }
            
            float heightModifier = 0.5 + 0.5 * pow(abs(1.0 - 2.0*t), 0.2);
            vec3 targetCenter = vec3(0.0, heightModifier * focusHeight, 0.0);
            vec3 dir = normalize(center - targetCenter);
            vec3 targetPoint = targetCenter + dir * focusRadius;
            
            if (t < 0.25 || t > 0.75) {
              return center;
            } else if (t < 0.45) {
              return mix(center, targetPoint, pow((t - 0.25) * 5.0, 4.0));
            } else if (t < 0.55) {
              float churn = 0.1;
              float transitionT = (t - 0.45) * 10.0;
              float angle = transitionT * 2.0 * PI;
              vec3 rotvec = vec3(sin(angle), 0.0, cos(angle));
              float strength = sin(transitionT * PI);
              return targetPoint + cross(dir, rotvec) * churn * strength;
            } else {
              return mix(targetPoint, center, pow((t - 0.55) * 5.0, 4.0));
            }
          }

          vec3 applyFocusScale(vec3 scales, float t, float targetScale, bool isFocused) {
            if (!isFocused) {
              return scales;
            }
            
            vec3 targetScales = targetScale * vec3(1.5, 1.5, 1.5); // 1.5x scale for focused
            if (t < 0.25) {
              return scales;
            } else if (t < 0.45) {
              return mix(scales, targetScales, pow((t - 0.25) * 5.0, 2.0));
            } else if (t < 0.55) {
              return targetScales;
            } else if (t < 0.75) {
              return mix(targetScales, scales, pow((t - 0.55) * 5.0, 2.0));
            } else {
              return scales;
            }
          }

          float applyFocusOpacity(float opacity, float t, bool fadeIn, bool isFocused) {
            if (!isFocused) {
              return opacity;
            }
            
            if (fadeIn) {
              if (t < 0.4) {
                return 0.0;
              } else if (t < 0.6) {
                return mix(0.0, opacity, pow((t - 0.4) * 5.0, 2.0));
              } else {
                return opacity;
              }
            } else {
              if (t < 0.4) {
                return opacity;
              } else if (t < 0.6) {
                return mix(opacity, 0.0, pow((t - 0.4) * 5.0, 2.0));
              } else {
                return 0.0;
              }
            }
          }
          `)
        ],
        statements: ({ inputs, outputs }) => dyno.unindentLines(`
          ${outputs.gsplat} = ${inputs.gsplat};
          ${outputs.gsplat}.center = applyFocusCenter(${inputs.gsplat}.center, ${inputs.t}, ${inputs.focusRadius}, ${inputs.focusHeight}, ${inputs.isFocused});
          ${outputs.gsplat}.scales = applyFocusScale(${inputs.gsplat}.scales, ${inputs.t}, ${inputs.splatScale}, ${inputs.isFocused});
          if (${inputs.inTransition} && ${inputs.isFocused}) {
            ${outputs.gsplat}.rgba.a = applyFocusOpacity(${inputs.gsplat}.rgba.a, ${inputs.t}, ${inputs.fadeIn}, ${inputs.isFocused});
          }
        `),
      });
    }

    function getAdvancedTransitionModifier(
      inTransition,
      fadeIn,
      t,
      splatScale,
      focusRadius,
      focusHeight,
      isFocused
    ) {
      const advancedTransition = createAdvancedTransitionDyno();
      return dyno.dynoBlock(
        { gsplat: dyno.Gsplat },
        { gsplat: dyno.Gsplat },
        ({ gsplat }) => {
          gsplat = advancedTransition.apply({
            gsplat, inTransition, fadeIn, t, splatScale, focusRadius, focusHeight, isFocused
          }).gsplat;
          return { gsplat };
        },
      );
    }

    // Enhanced focus system with cool transition animations
    function focusOnImage(index) {
      console.log('focusOnImage called with index:', index, 'splatMeshes.length:', splatMeshes.length);
      
      if (index >= 0 && index < splatMeshes.length) {
        quantumState.focusedIndex = index;
        currentFocusedImage = index;
        
        // Animate transition between images
        splatMeshes.forEach((mesh, i) => {
          if (i === index) {
            // Animate the new focused image in
            animateImageIn(mesh, i);
          } else {
            // Animate the old focused image out
            animateImageOut(mesh, i);
          }
        });
        
        // For now, disable the complex transition system to ensure focus works
        // Apply simple focus without transition modifiers
        splatMeshes.forEach((splatMesh, i) => {
          if (splatMesh.packedSplats && splatMesh.packedSplats.numSplats) {
            // Remove world modifier to prevent interference
            splatMesh.worldModifier = null;
            splatMesh.updateGenerator();
          } else {
            // For non-SplatMesh objects (like placeholder cubes), just update scale
            const baseScale = splatMesh.userData.originalScale || 2.0; // Increased from 1.0
            const focusMultiplier = i === index ? 1.5 : 1.0;
            splatMesh.scale.setScalar(baseScale * focusMultiplier);
            splatMesh.userData.isFocused = (i === index);
          }
        });
        
        // Get the focused mesh for camera updates
        const focusedMesh = splatMeshes[index];
        const targetPosition = focusedMesh.position;
        
        // Update focal distance based on distance to camera
        const distance = camera.position.distanceTo(targetPosition);
        spark.focalDistance = distance;
        
        // Update controls target to focus on the image
        if (orbitControls && orbitControls.target) {
          orbitControls.target.copy(targetPosition);
        }
        
        updateImageCounter();
        updateApertureAngle();
        
        console.log(`Focused on image ${index + 1}, position:`, targetPosition);
      }
    }
    
    // Animate image coming in with cool effects
    function animateImageIn(mesh, index) {
      const baseScale = mesh.userData.originalScale || 2.0;
      const targetScale = baseScale * 1.5;
      
      // Start from small scale and invisible
      mesh.scale.setScalar(0.1);
      mesh.visible = true;
      mesh.userData.isFocused = true;
      
      // Create transition particles
      createTransitionParticles(mesh.position, 'in');
      
      // Store original position
      const originalPosition = mesh.position.clone();
      
      // Jump effect - start from above
      mesh.position.y += 5;
      
      // Create animation timeline
      const startTime = Date.now();
      const duration = 800; // 800ms animation
      
      function animateIn() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Smooth easing
        const easeProgress = 1 - Math.pow(1 - progress, 3); // Cubic ease-out
        
        // Scale animation
        const currentScale = 0.1 + (targetScale - 0.1) * easeProgress;
        mesh.scale.setScalar(currentScale);
        
        // Jump down animation
        const jumpProgress = Math.sin(progress * Math.PI) * 0.5 + 0.5;
        mesh.position.y = originalPosition.y + 5 * (1 - jumpProgress);
        
        // Rotation effect during jump
        mesh.rotation.y = progress * Math.PI * 2; // Full spin
        
        // Bounce effect at the end
        if (progress > 0.8) {
          const bounce = Math.sin((progress - 0.8) * 50) * 0.1;
          mesh.scale.setScalar(currentScale + bounce);
        }
        
        if (progress < 1) {
          requestAnimationFrame(animateIn);
        } else {
          // Final state
          mesh.scale.setScalar(targetScale);
          mesh.position.copy(originalPosition);
          mesh.rotation.y = 0;
          console.log(`Animation complete for image ${index}`);
        }
      }
      
      animateIn();
    }
    
    // Animate image going out with cool effects
    function animateImageOut(mesh, index) {
      if (!mesh.visible) return; // Already hidden
      
      const baseScale = mesh.userData.originalScale || 2.0;
      const startScale = mesh.scale.x;
      
      // Create transition particles
      createTransitionParticles(mesh.position, 'out');
      
      // Store original position
      const originalPosition = mesh.position.clone();
      
      // Create animation timeline
      const startTime = Date.now();
      const duration = 600; // 600ms animation
      
      function animateOut() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Smooth easing
        const easeProgress = Math.pow(progress, 2); // Quadratic ease-in
        
        // Scale down animation
        const currentScale = startScale * (1 - easeProgress * 0.8);
        mesh.scale.setScalar(currentScale);
        
        // Slide out to the side
        const slideDirection = index < currentFocusedImage ? -1 : 1;
        mesh.position.x = originalPosition.x + slideDirection * 10 * easeProgress;
        
        // Fade out effect
        mesh.position.y = originalPosition.y - 2 * easeProgress;
        
        // Rotation effect
        mesh.rotation.z = progress * Math.PI * 0.5;
        
        if (progress < 1) {
          requestAnimationFrame(animateOut);
        } else {
          // Hide the mesh
          mesh.visible = false;
          mesh.userData.isFocused = false;
          mesh.position.copy(originalPosition);
          mesh.rotation.z = 0;
          console.log(`Hide animation complete for image ${index}`);
        }
      }
      
      animateOut();
    }
    
    // Create transition particles for cool effects
    function createTransitionParticles(position, type) {
      const particleCount = type === 'in' ? 30 : 20;
      const particles = [];
      
      for (let i = 0; i < particleCount; i++) {
        const geometry = new THREE.SphereGeometry(0.02, 8, 8);
        const material = new THREE.MeshBasicMaterial({ 
          color: new THREE.Color().setHSL(
            type === 'in' ? 0.6 + Math.random() * 0.2 : 0.1 + Math.random() * 0.2, 
            0.8, 
            0.6
          ),
          transparent: true,
          opacity: 0.8
        });
        const particle = new THREE.Mesh(geometry, material);
        
        particle.position.copy(position);
        
        // Different velocity patterns for in/out
        if (type === 'in') {
          // Particles explode outward from center
          particle.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3
          );
        } else {
          // Particles implode toward center
          const direction = new THREE.Vector3(
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2
          ).normalize();
          particle.velocity = direction.multiplyScalar(0.2);
        }
        
        particle.life = 1.0;
        particle.type = type;
        particle.userData.isParticle = true;
        
        scene.add(particle);
        particles.push(particle);
      }
      
      // Animate particles
      const animateParticles = () => {
        particles.forEach((particle, index) => {
          if (type === 'in') {
            // Outward explosion
            particle.position.add(particle.velocity);
            particle.velocity.multiplyScalar(0.95);
          } else {
            // Inward implosion
            particle.position.add(particle.velocity);
            particle.velocity.multiplyScalar(1.05);
          }
          
          particle.life -= 0.02;
          particle.material.opacity = particle.life;
          particle.scale.setScalar(particle.life);
          
          // Add rotation for extra effect
          particle.rotation.x += 0.1;
          particle.rotation.y += 0.1;
          
          if (particle.life <= 0) {
            scene.remove(particle);
            particles.splice(index, 1);
          }
        });
        
        if (particles.length > 0) {
          requestAnimationFrame(animateParticles);
        }
      };
      
      animateParticles();
    }

    // Clean image transition - NO EXTRA EFFECTS
    function triggerCleanImageTransition(index) {
      if (splatMeshes[index]) {
        const splatMesh = splatMeshes[index];
        
        // Simple scale and opacity transition
        splatMesh.userData.cleanTransition = {
          startTime: time.value,
          duration: 1.0,
          startScale: splatMesh.scale.x,
          targetScale: splatMesh.scale.x * 1.2
        };
        
        // Update the world modifier for transition
        const period = dyno.dynoFloat(splatFiles.length);
        const { inTransition, isFadeIn, normT } = getTransitionState(
          time,
          dyno.dynoFloat(index),
          dyno.dynoFloat((index + 1) % splatFiles.length),
          period
        );
        
        const splatScale = dyno.div(
          dyno.mul(dyno.dynoFloat(1.0), dyno.dynoFloat(1.0)),
          dyno.dynoFloat(splatMesh.packedSplats.numSplats / 1000.0)
        );
        
        splatMesh.worldModifier = getQuantumModifier(
          inTransition,
          isFadeIn,
          normT,
          quantumPhase,
          splatScale,
          dyno.dynoFloat(QUANTUM_PARAMS.entanglementStrength),
          dyno.dynoFloat(QUANTUM_PARAMS.waveFunction),
          dyno.dynoFloat(QUANTUM_PARAMS.uncertainty),
          dyno.dynoFloat(QUANTUM_PARAMS.quantumField)
        );
        splatMesh.updateGenerator();
      }
    }

    // Clean gallery mode switching - IMAGES ONLY
    function switchGalleryMode(mode) {
      if (quantumState.currentMode !== mode) {
        quantumState.currentMode = mode;
        quantumState.startTransition();
        
        // Store current positions as starting positions
        splatMeshes.forEach((splatMesh, index) => {
          splatMesh.userData.originalPosition = splatMesh.position.clone();
          splatMesh.userData.originalScale = splatMesh.scale.x;
        });
        
        console.log(`Switched to ${mode} mode: ${galleryLayouts[mode].description}`);
      }
    }

    // Update aperture angle for DoF
    function updateApertureAngle() {
      if (spark.focalDistance > 0) {
        spark.apertureAngle = 2 * Math.atan(0.5 * QUANTUM_PARAMS.apertureSize / spark.focalDistance);
      } else {
        spark.apertureAngle = 0.0;
      }
    }

    // Update image counter display with enhanced status
    function updateImageCounter() {
      const currentImageElement = document.getElementById('currentImage');
      const totalImagesElement = document.getElementById('totalImages');
      const imageCountElement = document.getElementById('imageCount');
      
      if (currentImageElement) {
        currentImageElement.textContent = currentFocusedImage + 1;
      }
      if (totalImagesElement) {
        totalImagesElement.textContent = splatMeshes.length;
      }
      if (imageCountElement) {
        imageCountElement.textContent = splatMeshes.length;
      }
      
      // Create enhanced status display
      const statusDiv = document.getElementById('quantumStatus') || createStatusDisplay();
      if (statusDiv) {
        statusDiv.innerHTML = `
          <div style="position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 10px; font-family: monospace; z-index: 1000; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2);">
            <div style="margin-bottom: 10px; font-size: 18px; font-weight: bold; color: #00ffff;">🌌 Quantum Gallery</div>
            <div style="margin-bottom: 5px;">📷 Image: ${currentFocusedImage + 1} / ${splatMeshes.length}</div>
            <div style="margin-bottom: 5px;">⚛️ State: ${quantumState.quantumState}</div>
            <div style="margin-bottom: 5px;">🎨 Style: ${quantumState.neuralStyle}</div>
            <div style="margin-bottom: 5px;">🔄 Auto: ${quantumState.autoTransitions ? 'ON' : 'OFF'}</div>
            <div style="margin-bottom: 5px;">🌌 BG: ${currentBackgroundType}</div>
            <div style="margin-top: 10px; font-size: 12px; opacity: 0.8; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 10px;">
              <div>← → Navigate | Q: State | N: Style</div>
              <div>B: BG | T: Auto | Enter: Effect | R: Reset</div>
            </div>
          </div>
        `;
      }
    }
    
    // Create status display element
    function createStatusDisplay() {
      const statusDiv = document.createElement('div');
      statusDiv.id = 'quantumStatus';
      document.body.appendChild(statusDiv);
      return statusDiv;
    }
    
    // Function to change background
    function changeBackground(type) {
      currentBackgroundType = type;
      
      // Remove existing skybox
      const existingSkybox = scene.children.find(child => child.userData.isSkybox);
      if (existingSkybox) {
        scene.remove(existingSkybox);
      }
      
      // Remove all non-essential scene objects when not using sky background
      if (type !== 'sky') {
        // Remove scene geometry
        const sceneGeometry = scene.children.find(child => child.userData.isSceneGeometry);
        if (sceneGeometry) {
          scene.remove(sceneGeometry);
        }
        
        // Remove any other scene objects that might cause black shapes
        scene.children.forEach(child => {
          if (child.userData && child.userData.isSceneObject) {
            scene.remove(child);
          }
        });
      }
      
      switch(type) {
        case 'sky':
          // Load 3D skybox
          loadDelitGLB(backgroundOptions.skyFile, true).then(skySphere => {
            skySphere.userData.isSkybox = true;
            scene.add(skySphere);
            
            // Load scene geometry if not already loaded
            const sceneGeometry = scene.children.find(child => child.userData.isSceneGeometry);
            if (!sceneGeometry) {
              loadDelitGLB(sceneFile).then(sceneAssets => {
                const sceneScale = 3.5;
                sceneAssets.scale.set(sceneScale, sceneScale, sceneScale);
                sceneAssets.position.set(-1, 0, -0.8);
                sceneAssets.userData.isSceneGeometry = true;
                sceneAssets.userData.isSceneObject = true;
                sceneAssets.visible = true;
                scene.add(sceneAssets);
              }).catch(error => {
                console.warn("Failed to load scene geometry:", error);
              });
            } else {
              sceneGeometry.visible = true;
            }
          }).catch(error => {
            console.warn("Failed to load skybox, falling back to solid color:", error);
            changeBackground('solid');
          });
          break;
          
        case 'solid':
          // Solid color background - fallback only
          renderer.setClearColor(backgroundOptions.backgroundColor, 1);
          break;
          
        case 'space':
        case 'galaxy':
        case 'nebula':
        case 'aurora':
        case 'sunset':
        case 'ocean':
        case 'forest':
        case 'mountains':
          // Image background - aggressive cleanup
          cleanupSceneObjects();
          createImageBackground(type);
          break;
          
        default:
          renderer.setClearColor(backgroundOptions.backgroundColor, 1);
      }
      
      console.log(`Background changed to: ${type}`);
      
      // Additional cleanup for non-sky backgrounds
      if (type !== 'sky') {
        cleanupSceneObjects();
      }
    }
    
    // Clean up any remaining scene objects that might cause black shapes
    function cleanupSceneObjects() {
      console.log('Cleaning up scene objects...');
      
      // Get all children to avoid modification during iteration
      const childrenToCheck = [...scene.children];
      
      childrenToCheck.forEach(child => {
        // Keep only essential objects
        const shouldKeep = 
          child === camera || // Keep camera
          child === spark || // Keep spark renderer
          child.userData && child.userData.isSkybox || // Keep skybox
          child.userData && child.userData.index !== undefined || // Keep splat meshes (images)
          child.userData && child.userData.isParticle; // Keep particles
        
        // Additional check: remove objects positioned above images (Y > 0)
        if (child.position && child.position.y > 0 && !shouldKeep) {
          console.log('Removing object above images:', child.name || child.type, 'at Y:', child.position.y);
          scene.remove(child);
          return;
        }
        
        if (!shouldKeep) {
          console.log('Removing object:', child.name || child.type, child);
          scene.remove(child);
        }
      });
      
      console.log('Scene cleanup complete. Remaining objects:', scene.children.length);
      
      // Additional cleanup: remove any objects positioned above images
      removeObjectsAboveImages();
    }
    
    // Remove objects positioned above the images
    function removeObjectsAboveImages() {
      const heightThreshold = 0.5; // Remove objects above this Y position
      
      const childrenToCheck = [...scene.children];
      childrenToCheck.forEach(child => {
        if (child.position && child.position.y > heightThreshold) {
          // Don't remove essential objects
          const isEssential = 
            child === camera ||
            child === spark ||
            child.userData && child.userData.isSkybox ||
            child.userData && child.userData.index !== undefined ||
            child.userData && child.userData.isParticle;
          
          if (!isEssential) {
            console.log('Removing object above threshold:', child.name || child.type, 'Y:', child.position.y);
            scene.remove(child);
          }
        }
      });
    }
    

    
    // Create image background (same as original sky)
    // All background images now work exactly like the sky - full image backgrounds
    function createImageBackground(imageType) {
      const imageUrl = backgroundOptions.imageBackgrounds[imageType];
      if (!imageUrl) {
        console.error(`Background image '${imageType}' not found`);
        return;
      }
      
      // Remove existing skybox/background
      const existingSkybox = scene.children.find(child => child.userData.isSkybox);
      if (existingSkybox) {
        scene.remove(existingSkybox);
      }
      
      // Create texture loader for images
      const textureLoader = new THREE.TextureLoader();
      
      console.log(`Loading background image: ${imageUrl}`);
      
      // Load the image texture
      textureLoader.load(
        imageUrl,
        (texture) => {
          console.log(`Background image loaded successfully:`, imageType);
          
          // Configure texture for skybox
          texture.mapping = THREE.EquirectangularReflectionMapping;
          texture.colorSpace = THREE.SRGBColorSpace;
          texture.generateMipmaps = false;
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          
          // Create sky sphere (same size as original sky)
          const skyGeometry = new THREE.SphereGeometry(500, 64, 64);
          const skyMaterial = new THREE.MeshBasicMaterial({ 
            map: texture, 
            side: THREE.BackSide,
            fog: false
          });
          const skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);
          skyMesh.userData.isSkybox = true;
          skyMesh.userData.imageType = imageType;
          skyMesh.renderOrder = -1; // Render first
          
          scene.add(skyMesh);
          console.log(`Background image '${imageType}' applied successfully`);
        },
        (progress) => {
          console.log(`Loading progress: ${(progress.loaded / progress.total * 100).toFixed(2)}%`);
        },
        (error) => {
          console.error(`Failed to load background image '${imageType}':`, error);
          // Create a simple colored background as fallback
          createSimpleBackground(imageType);
        }
      );
    }
    
    // Create simple background as fallback
    function createSimpleBackground(imageType) {
      console.log(`Creating simple background for: ${imageType}`);
      
      // Create a simple colored sphere as background
      const geometry = new THREE.SphereGeometry(500, 32, 32);
      const material = new THREE.MeshBasicMaterial({ 
        color: getBackgroundColor(imageType),
        side: THREE.BackSide
      });
      const sphere = new THREE.Mesh(geometry, material);
      sphere.userData.isSkybox = true;
      sphere.userData.imageType = imageType;
      sphere.renderOrder = -1;
      
      scene.add(sphere);
      console.log(`Simple background created for: ${imageType}`);
    }
    
    // Get background color based on type
    function getBackgroundColor(imageType) {
      const colors = {
        space: 0x000033,
        galaxy: 0x330033,
        nebula: 0x330066,
        aurora: 0x006633,
        sunset: 0x663300,
        ocean: 0x003366,
        forest: 0x003300,
        mountains: 0x333333
      };
      return colors[imageType] || 0x000000;
    }

    // Advanced image effect updates - IMAGES ONLY
    function updateCleanEffects(deltaTime) {
      splatMeshes.forEach((splatMesh, index) => {
        const timeValue = Date.now() * 0.001;
        
        // Update clean transition effects
        if (splatMesh.userData.cleanTransition) {
          const effect = splatMesh.userData.cleanTransition;
          const elapsed = time.value - effect.startTime;
          const progress = Math.min(elapsed / effect.duration, 1.0);
          
          if (progress < 1.0) {
            const easeProgress = Math.sin(progress * Math.PI * 0.5);
            const currentScale = effect.startScale + (effect.targetScale - effect.startScale) * easeProgress;
            splatMesh.scale.setScalar(currentScale);
          } else {
            delete splatMesh.userData.cleanTransition;
          }
        }
        
        // Advanced image breathing effect
        if (quantumState.imageBreathing) {
          const breathing = Math.sin(timeValue * quantumState.breathingSpeed + index) * quantumState.breathingAmplitude;
          const baseScale = splatMesh.userData.originalScale || 0.4;
          const focusMultiplier = splatMesh.userData.isFocused ? 1.5 : 1.0;
          splatMesh.scale.setScalar((baseScale + breathing) * focusMultiplier);
        }
        
        // Image pulse effect
        if (quantumState.imagePulse) {
          const pulse = Math.sin(timeValue * quantumState.pulseSpeed + index) * quantumState.pulseIntensity;
          const baseScale = splatMesh.userData.originalScale || 0.4;
          const focusMultiplier = splatMesh.userData.isFocused ? 1.5 : 1.0;
          splatMesh.scale.setScalar((baseScale + pulse) * focusMultiplier);
        }
        
        // Image tilt effect
        if (quantumState.imageTilt) {
          const tilt = Math.sin(timeValue * quantumState.tiltSpeed + index) * quantumState.tiltAmount;
          splatMesh.rotation.z = tilt;
        }
        
        // Image glow effect
        if (quantumState.imageGlow) {
          const glow = Math.sin(timeValue * 2 + index) * quantumState.glowIntensity;
          // Use scale variation instead of emissive for glow effect
          const glowScale = 1.0 + Math.max(0, glow) * 0.3;
          const focusMultiplier = splatMesh.userData.isFocused ? 1.5 : 1.0;
          splatMesh.scale.setScalar(splatMesh.userData.originalScale * glowScale * focusMultiplier);
        }
        
        // Image shake effect
        if (quantumState.imageShake) {
          const shakeX = (Math.random() - 0.5) * quantumState.shakeIntensity;
          const shakeY = (Math.random() - 0.5) * quantumState.shakeIntensity;
          splatMesh.position.x += shakeX;
          splatMesh.position.y += shakeY;
        }
        
        // Image zoom effect
        if (quantumState.imageZoom) {
          const zoom = Math.sin(timeValue * quantumState.zoomSpeed + index) * quantumState.zoomRange;
          const baseScale = splatMesh.userData.originalScale || 0.4;
          const focusMultiplier = splatMesh.userData.isFocused ? 1.5 : 1.0;
          splatMesh.scale.setScalar((baseScale + zoom) * focusMultiplier);
        }
        
        // Image wobble effect
        if (quantumState.imageWobble) {
          const wobble = Math.sin(timeValue * quantumState.wobbleSpeed + index) * quantumState.wobbleAmount;
          splatMesh.rotation.x = wobble;
          splatMesh.rotation.y = wobble * 0.5;
        }
        
        // Image spin effect
        if (quantumState.imageSpin) {
          splatMesh.rotation.y += deltaTime * quantumState.spinSpeed;
        }
        
        // Image bounce effect
        if (quantumState.imageBounce) {
          const bounce = Math.abs(Math.sin(timeValue * quantumState.bounceSpeed + index)) * quantumState.bounceHeight;
          splatMesh.position.y += bounce * deltaTime;
        }
        
        // Image fade effect
        if (quantumState.imageFade) {
          const fade = (Math.sin(timeValue * quantumState.fadeSpeed + index) + 1) * 0.5;
          // Use scale variation instead of opacity for fade effect
          const fadeScale = 0.3 + fade * 0.7;
          const focusMultiplier = splatMesh.userData.isFocused ? 1.5 : 1.0;
          splatMesh.scale.setScalar(splatMesh.userData.originalScale * fadeScale * focusMultiplier);
        }
        
        // Image scale effect
        if (quantumState.imageScale) {
          const scale = Math.sin(timeValue * quantumState.scaleSpeed + index) * quantumState.scaleRange;
          const baseScale = splatMesh.userData.originalScale || 0.4;
          const focusMultiplier = splatMesh.userData.isFocused ? 1.5 : 1.0;
          splatMesh.scale.setScalar((baseScale + scale) * focusMultiplier);
        }
        
        // Advanced effects (inspired by examples)
        updateAdvancedEffects(splatMesh, index, timeValue, deltaTime);
      });
    }

    // Advanced effects inspired by examples
    function updateAdvancedEffects(splatMesh, index, timeValue, deltaTime) {
      // Morphing effect (inspired by image-morphing)
              if (quantumState.morphingEnabled) {
          const morph = Math.sin(timeValue * quantumState.morphingSpeed + index) * quantumState.morphingIntensity;
        splatMesh.position.x += Math.sin(morph) * 0.1;
        splatMesh.position.y += Math.cos(morph) * 0.1;
        splatMesh.rotation.z = morph * 0.5;
      }
      
      // Color shift effect (inspired by neural-style-transfer)
              if (quantumState.colorShiftEnabled) {
          const colorShift = Math.sin(timeValue * quantumState.colorShiftSpeed + index) * quantumState.colorShiftAmount;
        splatMesh.position.z += colorShift * 0.2;
        splatMesh.scale.setScalar(splatMesh.userData.originalScale * (1.0 + colorShift * 0.1));
      }
      
      // Distortion effect (inspired by glsl)
              if (quantumState.distortionEnabled) {
          const distortion = Math.sin(timeValue * quantumState.distortionSpeed + index) * quantumState.distortionAmount;
        splatMesh.position.x += Math.sin(distortion * 10) * 0.05;
        splatMesh.position.y += Math.cos(distortion * 10) * 0.05;
        splatMesh.rotation.x = distortion * 0.3;
      }
      
      // Wave effect (inspired by particle-simulation)
              if (quantumState.waveEffectEnabled) {
          const wave = Math.sin(timeValue * quantumState.waveSpeed + index) * quantumState.waveAmplitude;
        splatMesh.position.y += wave;
        splatMesh.rotation.z = wave * 0.2;
      }
      
      // Ripple effect (inspired by dreamscape-portal)
              if (quantumState.rippleEffectEnabled) {
          const ripple = Math.sin(timeValue * quantumState.rippleSpeed + index) * quantumState.rippleRadius;
        const distance = Math.sqrt(splatMesh.position.x * splatMesh.position.x + splatMesh.position.y * splatMesh.position.y);
        const rippleEffect = Math.sin(distance - ripple) * 0.1;
        splatMesh.scale.setScalar(splatMesh.userData.originalScale * (1.0 + rippleEffect));
      }
      
      // Glow effect (inspired by dynamic-lighting)
              if (quantumState.glowEffectEnabled) {
          const glow = Math.sin(timeValue * 2 + index) * quantumState.glowIntensity;
        const glowScale = 1.0 + Math.max(0, glow) * 0.3;
        splatMesh.scale.setScalar(splatMesh.userData.originalScale * glowScale);
      }
      
      // Audio reactive effect (inspired by audio-visualizer)
              if (quantumState.audioReactiveEnabled) {
          const audio = Math.sin(timeValue * quantumState.audioFrequency + index) * quantumState.audioAmplitude;
        splatMesh.scale.setScalar(splatMesh.userData.originalScale * (1.0 + audio));
        splatMesh.position.z += audio * 0.2;
      }
      
      // Physics effect (inspired by splat-physics)
      if (quantumState.physicsEnabled) {
        // Simple physics simulation
        if (!splatMesh.userData.velocity) {
          splatMesh.userData.velocity = new THREE.Vector3(0, 0, 0);
        }
        
        splatMesh.userData.velocity.y -= quantumState.gravity * deltaTime;
        splatMesh.position.add(splatMesh.userData.velocity.clone().multiplyScalar(deltaTime));
        
        // Bounce off ground
        if (splatMesh.position.y < -3) {
          splatMesh.position.y = -3;
          splatMesh.userData.velocity.y *= -quantumState.bounce;
        }
        
        // Apply friction
        splatMesh.userData.velocity.multiplyScalar(quantumState.friction);
      }
      
      // Multi-view effect (inspired by multiple-viewpoints)
      if (quantumState.multiViewEnabled) {
        const viewOffset = index % quantumState.viewCount;
        const angle = (viewOffset / quantumState.viewCount) * Math.PI * 2;
        const radius = quantumState.viewSpacing;
        
        const targetX = Math.cos(angle) * radius;
        const targetY = Math.sin(angle) * radius;
        
        splatMesh.position.x += (targetX - splatMesh.position.x) * 0.1;
        splatMesh.position.y += (targetY - splatMesh.position.y) * 0.1;
      }
      
      // Procedural effect (inspired by procedural-splats)
      if (quantumState.proceduralEnabled) {
        const procedural = Math.sin(timeValue * quantumState.proceduralSpeed + index * quantumState.proceduralComplexity);
        splatMesh.rotation.y += procedural * 0.02;
        splatMesh.rotation.x += procedural * 0.01;
        splatMesh.position.z += procedural * 0.05;
      }
      
      // Texture effect (inspired by splat-texture)
      if (quantumState.textureEffectEnabled) {
        const texture = Math.sin(timeValue * quantumState.textureSpeed + index) * quantumState.textureIntensity;
        splatMesh.scale.setScalar(splatMesh.userData.originalScale * (1.0 + texture * 0.2));
        splatMesh.rotation.z = texture * 0.3;
      }
    }

    async function loadAssets(splatCoverage, spereRadius, sphereHeight) {
      console.log("Loading initial scene...");

      try {
        // Load initial background
        changeBackground('sky');

        // Load table GLB (only for sky background)
        if (currentBackgroundType === 'sky') {
          const sceneAssets = await loadDelitGLB(sceneFile);
          const sceneScale = 3.5;
          sceneAssets.scale.set(sceneScale, sceneScale, sceneScale);
          sceneAssets.position.set(-1, 0, -0.8);
          sceneAssets.userData.isSceneGeometry = true;
          sceneAssets.userData.isSceneObject = true;
          scene.add(sceneAssets);
        }
      } catch (error) {
        console.warn("Failed to load scene assets:", error);
        // Continue without scene assets
      }

      splatMeshes.length = 0; // Clear existing meshes
      const period = dyno.dynoFloat(splatFiles.length);
      
      console.log("Loading splat files:", splatFiles);
      
      for (let i=0; i<splatFiles.length; i++) {
        console.log(`Loading splat ${i+1}/${splatFiles.length}: ${splatFiles[i]}`);
        
        try {
          // Try to load with fallback URL if local fails
          let splatMesh = null;
          
          try {
            // First try local file
            const url = await getAssetFileURL(splatFiles[i]);
            splatMesh = new SplatMesh({
              url: url,
              onFrame: ({ mesh, time }) => {
                mesh.needsUpdate = true;
              }
            });
            await splatMesh.initialized;
          } catch (localError) {
            console.warn(`Local file failed for ${splatFiles[i]}, trying fallback:`, localError);
            
            // Try fallback URL
            try {
              splatMesh = new SplatMesh({
                url: fallbackUrls[i],
                onFrame: ({ mesh, time }) => {
                  mesh.needsUpdate = true;
                }
              });
              await splatMesh.initialized;
              console.log(`Fallback URL successful for ${splatFiles[i]}`);
            } catch (fallbackError) {
              console.error(`Both local and fallback failed for ${splatFiles[i]}:`, fallbackError);
              throw fallbackError;
            }
          }
          
          if (splatMesh) {
            console.log(`Splat ${i} loaded successfully:`, splatMesh);
            
            splatMesh.quaternion.set(1, 0, 0, 0);
            
            // Set initial position based on gallery mode
            const layout = galleryLayouts[quantumState.currentMode];
            if (layout && layout.positions[i]) {
              splatMesh.position.copy(layout.positions[i]);
              splatMesh.scale.setScalar(layout.scales[i]);
            } else {
              // Default positions if layout not available - make them more visible
              splatMesh.position.set((i - 1) * 4, 0, 0);
              splatMesh.scale.setScalar(2.0); // Increased from 0.6
            }
            
                      // Ensure the splat is visible
          // Note: SplatMesh handles visibility internally
            
            // Add user data for interaction
            splatMesh.userData.index = i;
            splatMesh.userData.originalPosition = splatMesh.position.clone();
            splatMesh.userData.originalScale = splatMesh.scale.x;
            
            // Set initial focus and visibility - only show first image
            if (i === 0) {
              splatMesh.userData.isFocused = true;
              splatMesh.visible = true;
              console.log(`Show initial image ${i}`);
            } else {
              splatMesh.userData.isFocused = false;
              splatMesh.visible = false;
              console.log(`Hide image ${i}`);
            }
            
            scene.add(splatMesh);
            splatMeshes.push(splatMesh);
            
            console.log(`Splat ${i} added to scene at position:`, splatMesh.position);
          } else {
            console.error(`Failed to create splat mesh for ${splatFiles[i]}`);
          }
          
        } catch (error) {
          console.error(`Error loading splat ${i}:`, error);
        }
      }
      
      console.log(`Total splats loaded: ${splatMeshes.length}`);
      
      // If no splats loaded, create a test splat
      if (splatMeshes.length === 0) {
        console.log("No splats loaded, creating test splat...");
        try {
          // Try to create a simple test splat using direct URL
          const testSplat = new SplatMesh({
            url: "https://sparkjs.dev/assets/splats/penguin.spz",
            onFrame: ({ mesh, time }) => {
              mesh.needsUpdate = true;
            }
          });
          
          await testSplat.initialized;
          testSplat.position.set(0, 0, 0);
          testSplat.scale.setScalar(2.0); // Increased from 0.6
          testSplat.userData.index = 0;
          testSplat.userData.originalPosition = testSplat.position.clone();
          testSplat.userData.originalScale = testSplat.scale.x;
          
          scene.add(testSplat);
          splatMeshes.push(testSplat);
          
          console.log("Test splat created successfully");
        } catch (error) {
          console.error("Failed to create test splat:", error);
        }
      }
      
      // Hide loading screen
      const loadingScreen = document.getElementById('quantum-loading');
      if (loadingScreen) {
        loadingScreen.style.display = 'none';
      }
      
      // Ensure we have multiple splat meshes for navigation
      if (splatMeshes.length <= 1) {
        console.warn("Not enough splat meshes loaded, creating multiple placeholders");
        
        // Create multiple placeholder meshes for testing navigation
        for (let i = 0; i < 5; i++) {
          const geometry = new THREE.BoxGeometry(1, 1, 1);
          const material = new THREE.MeshBasicMaterial({ 
            color: new THREE.Color().setHSL(i * 0.2, 0.8, 0.5) 
          });
          const placeholder = new THREE.Mesh(geometry, material);
          placeholder.position.set((i - 2) * 3, 0, 0); // Spread them out horizontally
          placeholder.userData.index = i;
          placeholder.userData.originalPosition = placeholder.position.clone();
          placeholder.userData.originalScale = 2.0; // Increased from 1.0
          scene.add(placeholder);
          splatMeshes.push(placeholder);
        }
        
        console.log(`Created ${splatMeshes.length} placeholder meshes for navigation testing`);
      }
      
      // Update counter after loading
      updateImageCounter();
      
      // Initialize gallery layout
      updateQuantumLayout();
      
      return splatMeshes;
    }

    const spereRadiusDyno =  dyno.dynoFloat(QUANTUM_PARAMS.entanglementStrength)
    const splatCoverageDyno = dyno.dynoFloat(QUANTUM_PARAMS.waveFunction)
    const sphereHeightDyno = dyno.dynoFloat(QUANTUM_PARAMS.uncertainty)
    await loadAssets(splatCoverageDyno, spereRadiusDyno, sphereHeightDyno);

    const gui = new GUI();
    
    // Simple controls
    gui.add(QUANTUM_PARAMS, "speedMultiplier").min(0.25).max(3.0).step(0.1).name("Speed");
    gui.add(QUANTUM_PARAMS, "rotation").name("Auto Rotate");
    gui.add(QUANTUM_PARAMS, "pause").name("Pause");
    
    // Gallery layout
    const galleryFolder = gui.addFolder("Gallery");
    const modeController = galleryFolder.add({ mode: 'carousel' }, 'mode', ['carousel', 'grid', 'spiral', 'galaxy'])
      .name("Layout")
      .onChange((value) => switchGalleryMode(value));
    
    galleryFolder.add({ currentImage: currentFocusedImage + 1 }, "currentImage", 1, splatFiles.length, 1)
      .name("Focus Image")
      .onChange((value) => focusOnImage(value - 1));
    
    // Depth of Field
    const dofFolder = gui.addFolder("Camera");
    dofFolder.add(QUANTUM_PARAMS, "focalDistance", 0, 15, 0.01).name("Focus Distance")
      .onChange(updateApertureAngle);
    dofFolder.add(QUANTUM_PARAMS, "apertureSize", 0, 0.4, 0.01).name("Aperture")
      .onChange(updateApertureAngle);

    console.log("Starting render loop");

    // Enhanced mouse interaction system
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let mouseDown = false;
    let mousePosition = new THREE.Vector2();
    let lastHoveredMesh = null;

    renderer.domElement.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(splatMeshes.filter(mesh => mesh.visible));

      if (intersects.length > 0) {
        const clickedMesh = intersects[0].object;
        const imageIndex = clickedMesh.userData.index;
        focusOnImage(imageIndex);
        
        // Click effect
        if (quantumState.clickEffectEnabled) {
          triggerClickEffect(clickedMesh);
        }
        
        // Update GUI
        const controller = galleryFolder.controllers.find(c => c.property === 'currentImage');
        if (controller) {
          controller.setValue(imageIndex + 1);
        }
      }
    });
    
    renderer.domElement.addEventListener('mousedown', (event) => {
      mouseDown = true;
      mousePosition.x = event.clientX;
      mousePosition.y = event.clientY;
    });
    
    renderer.domElement.addEventListener('mouseup', () => {
      mouseDown = false;
    });
    
    renderer.domElement.addEventListener('mousemove', (event) => {
      // Drag effect
      if (quantumState.mouseInteractionEnabled && mouseDown && quantumState.dragEnabled) {
        const deltaX = (event.clientX - mousePosition.x) * quantumState.dragSensitivity * 0.01;
        const deltaY = (event.clientY - mousePosition.y) * quantumState.dragSensitivity * 0.01;
        
        // Apply drag effect to focused image
        if (currentFocusedImage >= 0 && currentFocusedImage < splatMeshes.length) {
          const focusedMesh = splatMeshes[currentFocusedImage];
          focusedMesh.position.x += deltaX;
          focusedMesh.position.y -= deltaY;
        }
        
        mousePosition.x = event.clientX;
        mousePosition.y = event.clientY;
      }
      
      // Hover effect
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(splatMeshes.filter(mesh => mesh.visible));
      
      // Reset previous hover (but respect focus)
      if (lastHoveredMesh && lastHoveredMesh.userData.originalScale) {
        const focusMultiplier = lastHoveredMesh.userData.isFocused ? 1.5 : 1.0;
        const baseScale = lastHoveredMesh.userData.originalScale || 2.0; // Increased from 1.0
        lastHoveredMesh.scale.setScalar(baseScale * focusMultiplier);
      }
      
      // Apply hover effect to current mesh (but respect focus)
      if (intersects.length > 0) {
        const hoveredMesh = intersects[0].object;
        lastHoveredMesh = hoveredMesh;
        if (hoveredMesh.userData.originalScale) {
          const hoverMultiplier = hoveredMesh.userData.isFocused ? 1.5 : 1.2;
          const baseScale = hoveredMesh.userData.originalScale || 2.0; // Increased from 1.0
          hoveredMesh.scale.setScalar(baseScale * hoverMultiplier);
        }
      } else {
        lastHoveredMesh = null;
      }
    });
    
    function triggerClickEffect(mesh) {
      // Create a ripple effect on click
      const originalScale = mesh.userData.originalScale || 0.4;
      mesh.scale.setScalar(originalScale * 1.5);
      
      // Focus on clicked image
      const index = mesh.userData.index;
      if (index !== undefined) {
        currentFocusedImage = index;
        focusOnImage(index);
      }
      
      // Create particle explosion effect
      createParticleExplosion(mesh.position);
      
      setTimeout(() => {
        mesh.scale.setScalar(originalScale);
      }, 200);
    }
    
    // Particle explosion effect
    function createParticleExplosion(position) {
      const particleCount = 20;
      const particles = [];
      
      for (let i = 0; i < particleCount; i++) {
        const geometry = new THREE.SphereGeometry(0.02, 8, 8);
        const material = new THREE.MeshBasicMaterial({ 
          color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6),
          transparent: true,
          opacity: 0.8
        });
        const particle = new THREE.Mesh(geometry, material);
        
        particle.position.copy(position);
        particle.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2
        );
        particle.life = 1.0;
        particle.userData.isParticle = true;
        
        scene.add(particle);
        particles.push(particle);
      }
      
      // Animate particles
      const animateParticles = () => {
        particles.forEach((particle, index) => {
          particle.position.add(particle.velocity);
          particle.velocity.multiplyScalar(0.95);
          particle.life -= 0.02;
          particle.material.opacity = particle.life;
          particle.scale.setScalar(particle.life);
          
          if (particle.life <= 0) {
            scene.remove(particle);
            particles.splice(index, 1);
          }
        });
        
        if (particles.length > 0) {
          requestAnimationFrame(animateParticles);
        }
      };
      
      animateParticles();
    }

    // Enhanced keyboard navigation
    document.addEventListener('keydown', (event) => {
      console.log('Key pressed:', event.key, 'Current focused image:', currentFocusedImage, 'Total images:', splatMeshes.length);
      
      switch(event.key) {
        case 'ArrowLeft':
          currentFocusedImage = (currentFocusedImage - 1 + splatMeshes.length) % splatMeshes.length;
          console.log('Moving to previous image:', currentFocusedImage);
          focusOnImage(currentFocusedImage);
          break;
        case 'ArrowRight':
          currentFocusedImage = (currentFocusedImage + 1) % splatMeshes.length;
          console.log('Moving to next image:', currentFocusedImage);
          focusOnImage(currentFocusedImage);
          break;
        case ' ':
          QUANTUM_PARAMS.rotation = !QUANTUM_PARAMS.rotation;
          console.log('Toggled rotation:', QUANTUM_PARAMS.rotation);
          break;
        case 'r':
          // Reset camera
          camera.position.set(0, 0, 10);
          orbitControls.reset();
          console.log('Camera reset');
          break;
        case 'q':
          // Cycle quantum states
          cycleQuantumState();
          break;
        case 'm':
          // Toggle morphing
          quantumState.morphingActive = !quantumState.morphingActive;
          console.log('Morphing:', quantumState.morphingActive);
          break;
        case 'n':
          // Cycle neural styles
          cycleNeuralStyle();
          break;
        case 't':
          // Toggle auto-transitions
          quantumState.autoTransitions = !quantumState.autoTransitions;
          console.log('Auto transitions:', quantumState.autoTransitions);
          break;
        case 'Enter':
          // Trigger special effect on focused image
          if (splatMeshes[currentFocusedImage]) {
            triggerSpecialEffect(splatMeshes[currentFocusedImage]);
          }
          break;
        case 'b':
          // Cycle through background types
          cycleBackground();
          break;
          
        case 'c':
          // Manual cleanup - remove all non-essential objects
          console.log('Manual cleanup triggered');
          cleanupSceneObjects();
          break;
      }
    });
    
    // Cycle through quantum states
    function cycleQuantumState() {
      const states = ['superposition', 'entanglement', 'tunneling', 'teleportation', 'interference'];
      const currentIndex = states.indexOf(quantumState.quantumState);
      const nextIndex = (currentIndex + 1) % states.length;
      quantumState.quantumState = states[nextIndex];
      console.log('Quantum state changed to:', quantumState.quantumState);
    }
    
    // Cycle through neural styles
    function cycleNeuralStyle() {
      const styles = ['vanGogh', 'monet', 'picasso', 'kandinsky', 'hokusai', 'warhol', 'dali'];
      const currentIndex = styles.indexOf(quantumState.neuralStyle);
      const nextIndex = (currentIndex + 1) % styles.length;
      quantumState.neuralStyle = styles[nextIndex];
      console.log('Neural style changed to:', quantumState.neuralStyle);
    }
    
    // Cycle through background types - only 3D environments
    function cycleBackground() {
      const backgrounds = [
        'sky',
        'space', 'galaxy', 'nebula', 'aurora', 'sunset', 'ocean', 'forest', 'mountains'
      ];
      const currentIndex = backgrounds.indexOf(currentBackgroundType);
      const nextIndex = (currentIndex + 1) % backgrounds.length;
      changeBackground(backgrounds[nextIndex]);
    }
    
    // Special effect for focused image
    function triggerSpecialEffect(mesh) {
      // Create a quantum explosion
      const originalScale = mesh.userData.originalScale || 0.6;
      
      // Scale up dramatically
      mesh.scale.setScalar(originalScale * 3);
      
      // Add rotation
      mesh.rotation.z += Math.PI * 2;
      
      // Create energy field
      createEnergyField(mesh.position);
      
      // Reset after effect
      setTimeout(() => {
        mesh.scale.setScalar(originalScale);
        mesh.rotation.z = 0;
      }, 1000);
    }
    
    // Energy field effect
    function createEnergyField(position) {
      const ringCount = 3;
      const rings = [];
      
      for (let i = 0; i < ringCount; i++) {
        const geometry = new THREE.RingGeometry(0.5 + i * 0.3, 0.6 + i * 0.3, 32);
        const material = new THREE.MeshBasicMaterial({ 
          color: new THREE.Color().setHSL(0.6 + i * 0.1, 0.8, 0.6),
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
        const ring = new THREE.Mesh(geometry, material);
        
        ring.position.copy(position);
        ring.life = 1.0;
        ring.scale.setScalar(0);
        ring.userData.isParticle = true;
        
        scene.add(ring);
        rings.push(ring);
      }
      
      // Animate rings
      const animateRings = () => {
        rings.forEach((ring, index) => {
          ring.life -= 0.02;
          ring.scale.setScalar(1 + (1 - ring.life) * 2);
          ring.material.opacity = ring.life * 0.6;
          ring.rotation.z += 0.1;
          
          if (ring.life <= 0) {
            scene.remove(ring);
            rings.splice(index, 1);
          }
        });
        
        if (rings.length > 0) {
          requestAnimationFrame(animateRings);
        }
      };
      
      animateRings();
    }

    // Initial setup after assets are loaded
    updateApertureAngle();
    
    // Focus on first image after loading
    if (splatMeshes.length > 0) {
      console.log("Focusing on first image...");
      focusOnImage(0);
    } else {
      console.log("No splat meshes available for focus");
    }
    
    // Keyboard shortcuts info removed for clean interface

    // Animation loop
    let lastTime = 0;
    renderer.setAnimationLoop((rawTime) => {
      rawTime *= 0.0005;
      const deltaTime = rawTime - (lastTime ?? rawTime);
      lastTime = rawTime;
      orbitControls.update();
      renderer.render(scene, camera);

          if (!QUANTUM_PARAMS.pause) {
      time.value += deltaTime * QUANTUM_PARAMS.speedMultiplier;
        
        // Update gallery state
        quantumState.update(deltaTime);
        
        // Update manual transitions
        updateManualTransition(deltaTime);
        
        // Update gallery layout
        updateQuantumLayout();
        
        // Update floating animation
        updateGentleFloating(deltaTime);
        
        // Update effects
        updateCleanEffects(deltaTime);
        
        // Auto rotation with enhanced effects
        if (quantumState.autoRotate) {
          for (const splatMesh of splatMeshes) {
            splatMesh.rotation.y += deltaTime * quantumState.autoRotateSpeed;
            splatMesh.rotation.x += deltaTime * 0.2;
            splatMesh.rotation.z += deltaTime * 0.1;
          }
        } else if (QUANTUM_PARAMS.rotation) {
          for (const splatMesh of splatMeshes) {
            splatMesh.rotation.y += deltaTime * QUANTUM_PARAMS.speedMultiplier;
          }
        }
        
        // Auto quantum state cycling
        quantumState.autoStateTimer += deltaTime;
        if (quantumState.autoStateTimer > 10.0) { // Change state every 10 seconds
          cycleQuantumState();
          quantumState.autoStateTimer = 0;
        }
        
        // Auto neural style cycling
        quantumState.autoStyleTimer += deltaTime;
        if (quantumState.autoStyleTimer > 15.0) { // Change style every 15 seconds
          cycleNeuralStyle();
          quantumState.autoStyleTimer = 0;
        }
        
        // Auto transitions between images using time-based system
        if (quantumState.autoTransitions) {
          // Use time-based transitions instead of manual focus changes
          const transitionPeriod = 8.0; // 8 seconds per image
          const currentImageIndex = Math.floor(time.value / transitionPeriod) % splatMeshes.length;
          
          if (currentImageIndex !== currentFocusedImage) {
            currentFocusedImage = currentImageIndex;
            focusOnImage(currentFocusedImage);
          }
        }
        
        // Update transitions
        splatMeshes.forEach((splatMesh, index) => {
          if (splatMesh.userData.transitioning) {
            // Update transition effects
            const period = dyno.dynoFloat(splatFiles.length);
            const { inTransition, isFadeIn, normT } = getTransitionState(
              time,
              dyno.dynoFloat(index),
              dyno.dynoFloat((index + 1) % splatFiles.length),
              period
            );
            
                      const splatScale = dyno.div(
            dyno.mul(dyno.dynoFloat(QUANTUM_PARAMS.waveFunction), dyno.dynoFloat(QUANTUM_PARAMS.entanglementStrength)),
            dyno.dynoFloat(splatMesh.packedSplats.numSplats / 1000.0)
          );
            
                      splatMesh.worldModifier = getQuantumModifier(
            inTransition,
            isFadeIn,
            normT,
            quantumPhase,
            splatScale,
            dyno.dynoFloat(QUANTUM_PARAMS.entanglementStrength),
            dyno.dynoFloat(QUANTUM_PARAMS.uncertainty),
            dyno.dynoFloat(QUANTUM_PARAMS.quantumField),
            dyno.dynoFloat(QUANTUM_PARAMS.waveFunction)
          );
            splatMesh.updateGenerator();
          }
        });
      }
    });
  </script>
</body>
</html>
